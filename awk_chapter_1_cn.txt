
第一章 AWK 入门教程

AWK 是一门简便的，富有表现力的语言，它被广泛的用来进行各种计算和数据处理任务。这一章是一篇设计成让你尽快开始写你自己程序的入门教程。第二章描述了整个awk语言，余下的章节展示了用awk在许多不同的领域解决问题。贯穿本书始终，我们一直在努力为你挑选出有用的，有趣儿的，有启发性的例子。

1.1 开始

有用的awk程序通常很短，仅仅一两行。假设你有一个名叫 emp.data 的文件，里面包含了你的员工的姓名，每小时应付的工资数，工作的小时数，一位员工的记录占一行，像下面这样：

	Beth  4.00	0 
	Dan   3.75	0 
	Kathy 4.00	10 
	Mark  5.00	20 
	Mary  5.50	22 
	Susie 4.25 	18

现在你想得到每一位有实际工作时间的，员工的姓名和工资数。这类工作是awk天生擅长的，所以很简单。只需要输入下面的命令：

	awk '$3> 0 { print$1, $2*$3 }'  emp.data 

你应该得到下面的输出：

	Kathy 40 
	Mark 100 
	Mary 121 
	Susie 76.5

这个程序告诉系统运行awk ，具体的awk 程序是被单引号括起来的，awk 需要的数据从输入文件 emp.data中获得。在单引号中的是一段完整的awk程序，它由一个 模式-行为 语句构成。 $3 > 0 ，这个是模式，它用来匹配输入的每一行的第三列，或者说第三个字段，如果这一行的第三个字段大于零，

	{ print $1, $2 * $3 }

这个行为将会输出第一个字段，以及第二和第三字段的乘积。

如果你想得到没有工作的员工的姓名，输入下面的命令行：

	awk '$3 == 0 { print $1 }' emp.data 

在这里的模式 ：$3 == 0 匹配到第三个字段是零的行，随后的行为 ：	{ print $1 } 输出这一行的第一个字段。

当你阅读本书时，试着运行和修改一下这些提供的程序。因为大多数程序都是简短的，你将很快明白awk是如何工作的。在一个unix系统上，上述两个命令在终端里面运行，可能是这样的：

	$ awk '$3 > 0 { print $1, $2 * $3 }' emp.data 
	Kathy 40 
	Mark 100 
	Mary 121
	Susie 76.5 
	$ awk '$3 == 0 { print $1 }' emp.data 
	Beth 
	Dan 
	$

在行开头的 $ 是系统提示符，这个可能和你的机器不一样。

AWK 程序的结构

让我们回头看看这些是如何进行的。在上面的命令行中，单引号之间的部分，是用awk语言写的程序。本章中的每一个awk程序都是一系列的一个或多个 模式-行为 语句。

	模式 { 行为 } 
	模式 { 行为 }
	...

awk 的基本操作就是一行接一行的扫描输入的一系列的行，在这些行中寻找和程序中任一模式相“匹配”的行，依靠模式中的问题，来实现准确的“匹配”。如果 $3 > 0 ，它意味着“条件是真”。

每一个输入的行，被每一个模式轮流测试。对于匹配的每一个模式，相对应的行为（可以包括多个步骤）会被执行。然后下一行被读入，从头到尾再被每一个模式轮流测试是否匹配。这个一直持续进行到所有的输入行都被读入过了。

上面的程序是一个模式和行为的典型例子。

	$3 == 0 { print $1 }

是一个单独的模式-行为语句；对于每一个读入的行，如果它的第三个字段是零，它的第一个字段将被输出。在一个模式-行为语句中，模式或者是行为可以被省略（但是不能两个都省略）。如果一个模式没有指定行为，例如下面的语句：

	$3 == 0

每一个匹配这个模式的行（在这里，就是每一个满足条件的行）都会被输出。这个程序应用到 emp.data文件中，将会输出第三列是零的两行。

	Beth 4.00 0 
	Dan  3.75 0

如果只有行为，没有模式，例如下面的例子：

	{ print $1 }

这个例子中的行为，将会把输入的每一行的第一个字段都输出。

因为模式和行为都是可选项，行为是通过一对闭合的大括号和模式加以区分的。

运行一个awk程序

有几种运行awk程序的方式。你可以通过：

	awk '程序' 输入文件（多个）

在每一个指定的输入文件上运行程序。例如，你可以输入：

	awk '$3 == 0 { print $1 }' file1 file2

把file1 ,file2 文件中的，每一个第三个字段是零的行，它的第一个字段都找出来。

你可以省略输入文件，在命令行上键入：

	awk  'program '

在这个例子中，awk将把程序应用到你接下来输入的每一行上，直到你输入一个文件结束信号（在unix系统下，是 ctrl-d ）。这里是一个在unix上的简单例子：

	$ awk '$3 == 0 { print $1 } 
	Beth	4.00	0 
	Beth 
	Dan	3.75	0
	Dan 
	Kathy	3.75	10 
	Kathy	3.75	0 
	Kathy
	...

粗体字是计算机回应显示。

用awk非常容易尝试这种行为：先输入你的awk程序，然后输入你的数据，然后看看发生了什么。我们再次鼓励你尝试这个例子并且尝试各种变化。

注意一下，这个程序是在命令行上被单引号括起来的。类似于“$” 这种shell提示符，可以用来协助程序大于一行的输入。（这句话的意思应该是指，当awk程序本身大于一行，进行多行输入时，前面的类似于 $ 这种提示符会相应的变化）

这种安排方式对于短小的程序（只有几行）是比较方便的。如果awk程序写的很长，那么把它写入一个叫 “progfile”的文件里面，然后在命令行上调用，更方便些。

	awk -f progfile	optional list of input files 	

-f 选项提示awk从一个指定的“progfile”文件里面获取程序的内容，在这里，“progfile”可以写成任何文件名。


错误说明

如果你在awk程序里面犯了一个错误，awk就会给你提示一个诊断信息。例如，如果你输错了一个大括号，像这样的：

	awk '$3 == 0 [ print $1 }' emp.data

你就会得到这样一个信息：

	awk: syntax error at source line 1 
	context is
		$3==0>>> [<<< 
		extra } 
		missing  ]
	awk: bailing out at source line 1

"Syntax error" 意味着你犯了一个语法错误，它被检测出来了，位于 >>> <<< 之间的位置。 "Bailing out"意味着没有尝试修复。有时候，你可以从错误报告中得到更多的提示，如错误匹配的引号，大括号等。

由于语法错误，awk没有试图去执行这个程序。但是，有些错误，只有在你的程序已经运行了，才会被检测到。例如，你试图用一个数去除0，awk就会停止处理，然后报告一个行号，这个行号就是程序里面试图进行这个除法的那一行。

=====================

1.2 简单输出

这一章的其余部分，集合了一些处理上面提到的emp.data文件的短小，典型的awk程序。我们将简短的解释它们是如何运行的。这些例子蕴含了主要的，有用的操作，这些操作是使用awk非常容易完成的：打印一些字段，选择输入，转换数据。我们在这儿并没有演示用awk的所有手段可以做的全部事情，或是特定事情的大量细节。但是，当你读完这一章，你的收获会相当多，而且你会发现读后面的章节更容易了。

我们通常仅显示程序，而不是整个的命令行。在每个例子里，就像上面演示的一样，给出的程序要用单引号括起来，作为awk命令的第一个参数。或者，把它放到一个文件里面，让awk用上面的 -f 选项调用它。

在awk里面，仅仅有两种类型的数据：数字和字符串。emp.data文件就是这种信息的一个典型:包含单词和数字，这些单词和数字被空格或者tab隔开。

awk一次读入一行，然后把每一行用字段分开，默认情况下，在这里的字段是指包含字符的一个序列，这个序列里面不包含任何空格或tab。当前读入行的第一个字段被称为 $1，第二个字段被称为 $2 ......等等。当前的整行被称为 $0 。这一行到下一行，字段的数目可以发生变化。

通常，我们需要做的就是显示出每行的全部或者一些字段，也许，还要执行一些计算。这一章的程序都是这种样式的。

输出每一行：

如果一个行为没有指定模式，这个行为就会在所有输入的行上执行。下面这个语句将显示当前输入行本身，所以，程序是这样的：

	{ print }

这个语句将打印出所有输入到标准输出设备上。因为 $0 也表示整行：

	{ print $0 }

也会做同样的事情。

输出某些字段

在一个单独的输出语句中，可以有超过一个的字段被输出到同一行中。下面的程序会输出每个输入行的第一个和第三个字段。

	{ print $1, $3 } 

如果用 emp.data 文件作为输入，它产生的结果是

	Beth 0
	Dan 0
	Kathy 10
	Mark 20
	Mary 22
	Susie 18

================
在这个输出语句中，表达式的各部分被逗号分隔开。在默认情况下，被输出的字段间用一个空格分隔开，输出读入的每行，都会相应产生一个新行。这些默认的设置都是可以被修改的，我们将在第二章演示如何操作。

NF， 字段行号

也许上面这些让你感觉必须用 $1 ，$2 这种方式来引用字段，但其实，任何跟在$后面的表达式都可以用来表明字段数字；这种表达式经过演算，它的数值被用作表示字段数字。例如：awk会统计当前输入行的字段数，把这个数值存储在内建的 NF 变量里面。因此，下面的程序：

 	{ print NF, $1, $NF } 

将会输出每一行的字段数，第一个字段和最后一个字段的内容。


计算和输出

你可以利用字段的值做一些计算，并且把计算的结果输出。下面的程序：

	{ print $1, $2 * $3 } 

是一个典型的例子。这个程序输出每个员工的姓名和总的工资（时薪乘以小时数）：

	Beth 0 
	Dan 0 
	Kathy 40 
	Mark 100 
	Mary 121 
	Susie 76.5

过一会我们将演示怎么让这个输出看起来更规整一些。

输出行号

awk提供了另外一个内置变量，叫NR，这个变量可以算出当前读入行的行号。我们可以使用 NR 和 $0 ，这样输出 emp.data的每一行时，可以在前面加上行号。

	{ print NR, $0 }

输出看起来是这样的：

	1 Beth	4.00	0
	2 Dan	3.75	0
	3 Kathy	4.00	10
	4 Mark	5.00	20
	5 Mary	5.50	22
	6 Susie	4.25	18


在输出中放置文本

你可以在输出的字段中间，插入一些额外的单词或者某些计算结果

	{ print "total pay for", $1, "is", $2 * $3 }

会输出

	total pay for Beth is 0
	total pay for Dan is 0
	total pay for Kathy is 40
	total pay for Mark is 100
	total pay for Mary is 121
	total pay for Susie is 76.5

在这个输出语句中，被双引号括起来的文本，随着字段和计算结果被一同输出。

1.3 复杂输出

输出语句是为了快速和容易的输出而设计的。你可以随心所欲设置输出格式。你也许不得不使用 printf 语句。我们将在第2.4章节看到它，printf 几乎可以产生各种输出，但在这一章，我们仅仅显示一点它的能力。

对齐字段

printf 语句具有这种样式：

	printf(format, value1, value2, ••• , valueN,)

在这里，format 是一个字符串，其中包含的文本将被逐一输出，另外还包含一些后面的 value 输出时的格式说明。一个ges说明的形式就是一个 % 后面跟着几个字符，这些字符来控制后面的 value 输出时的格式。在 format 中，从左往右数，第一个格式说明是用来告知 format 后面的 value1 是如何输出的，第二个格式说明是告知 后面的value2 是如何输出的，依次等等。因此，在 format中指定的%开头的格式说明数量，要和后面被输出的value的个数一样。

这里有一个程序，它运用printf 为每个员工输出了总工资：

	{ printf("total pay for %s is $%.2f\n", $1, $2 * $3) } 

在这个printf语句中，包含了两个%开头的格式说明。

第一个格式说明 %s 表明它所对应的第一个输出值 $1 ，是一个字符串；第二个格式说明，%.2f 表明它所对应的第二个输出值 $2*$3 ，是一个小数点后面保留2位的数字。在这个格式说明之前有个$ ，美元符号，它被原样输出。双引号括起来的 format 部分的结尾是 \n ，代表另起一个新行，这个就会让随后的输出从一个新行开始。拿emp.data文件作为输入，这个程序产生的结果如下：

	total pay for Beth is $0.00 
	total pay for Dan is $0.00 
	total pay for Kathy is $40.00 
	total pay for Mark is $100.00 
	total pay for Mary is $121.00 
	total pay for Susie is $76.50

使用 printf，空格和新行不会自动产生，你必须自己手动创建。别忘了 \n 。

这是另外一个输出每个员工姓名和工资的程序：

	{ printf("%-8s $%6.2f\n", $1, $2 * $3) }

第一个格式说明，%-8s ,输出名字作为一个左测对齐的字符串，这个字符串的宽度固定为8个字符。 第2个格式 %6.2f ，输出有两位小数的工资数目，这个字段的宽度固定为6个字符(-8表示左侧对齐，没有- ，表示右侧对齐，译者注)。

	Beth     $  0.00
	Dan      $  0.00
	Kathy    $ 40.00
	Mark     $100.00
	Mary     $121.00
	Susie    $ 76.50

随着我们的进行，我们将演示更多的 printf 的例子，完整的说明在 2.4 章节。

对输出排序

假设，你想按照工资额的升序，打印每一位员工的所有数据。最简单的方法是使用awk，把工资额作为前缀，放到每一条员工记录的前面，然后，把运行出来的结果，传递给一个排序程序。在 Unix 下，命令行是这样的

	awk '{ printf("%-6.2f %s\n", $2 * $3, $0) }' emp.data | sort -n

利用管道的方式，把awk的输出结果传递到 sort 命令去， 产生的结果：

	0.00   Beth	4.00	0
	0.00   Dan	3.75	0
	40.00  Kathy	4.00	10
	76.50  Susie	4.25	18
	100.00 Mark	5.00	20
	121.00 Mary	5.50	22



注：原书的语句是%6.2f ，译者为了美观和验证左对齐，改为了%-6.2f  ，输出结果也相应修改了，见谅。  另外，原书中的 sort 命令没有参数，如果想要得到按数字排序的结果，需要加上 -n 参数。

1.4  筛选

Awk 的模式匹配非常适合我们从输入的文件中筛选出我们需要的行，然后做进一步的处理。因为一个模式的后面如果不跟任何行为操作的话，将输出所有匹配这个模式的行，所以许多的awk程序就仅仅包含一个模式。这一章给出了一些有用的例子：

通过比较来筛选

这个程序使用了一个比较模式，筛选出了每小时工作等于或大于5美元的员工的记录，因此，设置比较第2个字段大于或等于5:

	$2 >= 5 

它会从 emp.data 文件中筛选出这些行：

	Mark	5.00	20 
	Mary	5.50	22

通过计算筛选

这个程序 ：

	$2 * $3 > 50 { printf("$%.2f for %s\n", $2 * $3, $1) } 

就可以输出总工资大于50美元的员工的名单。

	$100.00 for Mark 
	$121.00 for Mary 
	$76.50 for Susie

通过文本内容筛选

除了数字测试之外，你还能通过特定的单词或短语来筛选输入的行。下面的程序输出所有第一个字段是 Susie 的行。

	$1 == "Susie"

== 这个操作是做相等的测试。你也可以通过正则表达式来描绘出包含一组特定的字母，单词和短语的文本。下面的程序输出在任何位置包含 Susie 的行。

    /Susie/

输出是这一行：

	Susie	4.25	18

正则表达式对于描述复杂的模式非常有用；章节2.1包含了一个完整的讨论。

组合模式

模式可以通过圆括号，用  逻辑运算符 &&, || ,和 ! 组合起来，这些运算符表示 与 ，或 ，非。 这个程序：

	$2 >= 4 || $3 >= 20

将会输出第二个字段至少是4 或者第三个字段至少是20的行：

	Beth	4.00	0 
	Kathy	4.00	10 
	Mark	5.00	20 
	Mary	5.50	22 
	Susie	4.25	18

某些行满足两个条件，但只会被输出一次。 对比一下下面的这个有两个模式构成的程序：

	$2 >= 4 
	$3 >= 20

如果有些行两个条件都满足，那么这些行将被输出两次。

	Beth	4.00	0 
	Kathy	4.00	10 
	Mark	5.00	20 
	Mark	5.00	20 
	Mary	5.50	22 
	Mary	5.50	22 
	Susie	4.25	18

注意之处

	!($2 < 4 && $3 < 20)

这个程序将输出那些第2个字段并非小于4，或者第3个字段并非小于20的行，这个条件其实和上面组合模式的第一个是相等的，只是这个可读性差些。

数据验证

在现实的数据中，总会有些错误。对于检查数据的合理性，是否具有正确的格式这种被称为数据验证的工作来说，awk是一个优秀的工具。

数据验证本质是一种找错工作：输出不符合要求的行，不输出符合要求的行。下面的程序应用了5个比较模式，对emp.data文件的每一行进行五种合理性的检查。


	NF != 3   { print $0, "number of fields is not equal to 3" }
	$2 < 3.35 { print $0, "rate is below minimum wage" } 
	$2 > 10   { print $0, "rate exceeds $10 per hour" }
	$3 < 0    { print $0, "negative hours worked" }
	$3 > 60   { print $0, "too many hours worked" }

如果emp.data文件里面没有错误，那么这个程序就不会有任何输出。

BEGIN 和 END

特定的BEGIN 模式匹配第一个输入文件的第一行读入之前，特定的END模式匹配最后一个输入文件的最后一行被处理之后。下面的程序使用 BEGIN 打印出一个表头：

	BEGIN { print "NAME RATE HOURS"; print "" } 
	{ print }

 你可以利用分号分隔，把几个单行的语句放在同一行上。注意, print "" 将会输出一个空行，而 print 不是输出空行，而是输出当前的输入行 （所以，第二行的 print 语句将整行都输出了 ）。

1.5 利用 awk 进行计算

一系列的语句可以用新行或分号进行分隔。你已经看到了刚才那个单独的 print 语句的例子。本章节给出一些进行数值计算和字符串统计的语句例子。在这些语句中，你不仅可以使用内建的NF这类变量，而且可以自己定义一些变量，用来执行计算，存储数据这种操作。在awk里面，用户创建变量不需要声明。

计算总数

这个程序用一个 emp 的变量来统计工作超过15个小时的员工数：

	$3> 15{ emp=emp+1 } 
	END	{ print emp, "employees worked more than 15 hours" }

每当找到一个第三个字段大于15的行，预设的变量 emp 的数值就会增加1，用 emp.data 作为输入文件，这个程序的输出如下：

	3 employees worked more than 15 hours 

awk 的变量默认值为数字 0 ，  所以我们不需要初始化 emp 。

计算总数和平均值

我们可以利用内置的 NR 这个变量来得到员工的总数，这个变量保存着读入的行数，在所有的行都读入之后，它的值就是读入的行数。

	END { print NR, "employees" } 

输出结果是 ：

	6 employees 

下面这个程序利用NR 来计算平均工资值：

	{ pay =pay + $2 * $3 } 
	END { print NR, "employees"
	      print "total pay is", pay 
              print "average pay is", pay/NR
            }

第一个行为是统计出所有员工的工资总额。这个 END 总的输出如下：

	6 employees 
	total pay is 337.5 
	average pay is 56.25

很明显， printf 也可以产生近似的输出。这里有一个潜在的错误：在不常见的例子里面，NR 的值是零，程序试图用零做除数，因此会产生一个错误信息。

处理文本

awk 的强项之一，它具有一种能力：可以像大多数语言处理数字那样，方便的处理字符串。awk 的变量可以像处理数字一样有效的处理字符串。下面的程序可以找出每小时工资最高的员工。

	$2 > maxrate { maxrate =$2; maxemp =$1 } 
	END { print "highest hourly rate:", maxrate, "for", maxemp }

它的输出是：

	highest hourly rate: 5.50 for Mary

在这个程序中，maxrate 变量保存着一个数值，同时，maxemp 变量保存着一个字符串。（如果有几个员工都是最高工资，这个程序将找出表里的第一个）。

连接字符串

可以通过组合老的字符串来创造新的字符串，这个操作叫做连接。下面的程序：

	{ names = names $1 " " } 
	END { print names }

通过追加每一个员工的名字和一个空格到变量 names 里面，搜集了所有员工的名字，放到了一个单独的字符串里面。 通过END 操作，输出了names的值：

	Beth Dan Kathy Mark Mary Susie

在 awk 程序中，通过一个接一个写入字符串的值，表达了连接操作。 在每一个输入行中，程序的第一条语句连接了三个字符串：names 变量上一次的值，每行的第一个字段，一个空格；然后把这个连接的结果又赋值给了 names 变量。因此，在所有的行被读入之后，names 变量里面就有这样一个字符串，这个字符串里面包含着所有员工的名字，每个名字后面跟着一个空格。存储字符串的变量的初始值是null 字符串（里面没有存储任何字符）,因此，程序里的names 变量不需要初始化声明。

输出最后一行

尽管在END 的时候，NR依然保持着它的值，而$0 没有，这个程序：

	{ last = $0 }
	END { print last } 

是输出最后一行的一种方法：

	Susie	4.25	18 

内置的功能

我们已经看到了，awk提供了一些内置的变量，这些变量被经常的，有效的的使用，像字段的数目，输入的行号这些。于此类似，awk也有一些内置的功能用来计算一些有用的数据。除了像平方根，对数，随机数这种数学功能之外，还有一些操作文本的功能。其中之一是length，这个功能可以统计出一个字符串中字符的个数。 例如，下面这个程序可以计算出每个员工的名字的长度。

	{ print $1, length($1) } 

结果如下：

	Beth 4 
	Dan 3 
	Kathy 5 
	Mark 4 
	Mary 4 

统计行数，单词数和字符数

下面的程序使用 length ,NF, 和 NR 来统计输入的行数，单词数和字符数。方便起见，我们假设每个字段是一个单词。

	{ nc =nc + length($0) + 1 
	  nw =nw + NF
        }
   END	{ print NR, "lines,.., nw, "words,", nc, "Characters" } 

运行这个程序，emp.data 文件的统计结果：

	6 lines, 18 words, 77 characters

因为文本文件每行的末尾会有一个换行符存在，所以，我们在输入的每一行的字符统计里，都加了1，而 length($0) 里面不包含这个换行符（这个统计程序认为，每行不可见的换行符也要统计在字符里面，这个和linux 下的wc 程序一样，wc 程序统计的字符里面，也是包含每行的换行符的 -- 译者注）。

awk 提供了 if-else 语句来做判断，其他几个语句用来写循环，所有的这些模式都可以在C语言里面找到。它们仅仅能被用在 actions 部分。

If-Else 语句

下面的程序计算所有每小时工资超过6美元的员工，他们的工资总额和平均工资。它使用了 if 语句，来防止在计算平均工资的时候，出现 0 做除数的情况。

	$2 > 6 { n =n + 1; pay =pay + $2 * $3} 
	END    { if (n > 0)
		     print n, "employees, total pay is" , pay, 
                              "average pay is" , pay/n
		 else 
		     print "no employees are paid more than $6/hour"
               }

对 emp.data 文件的输出是：

	no employees are paid more than $6/hour

在 if-else 语句中，跟在if语句后面的条件作为评估，如果它是真的，if段的语句将被执行，否则，else 段的语句将被执行。注意，我们可以通过在每一行的后面加逗号，把一个长的语句分为几行来写。

while 语句

一个while 语句包含一个条件和一段语句。当每次判断条件是真的时候，这段语句就被重复执行一次。下面的程序根据给出的本金，利息和年数来计算出你每一年的存款总数，使用了 总额= 本金*（1 + 利息）^ 年数 这个计算公式。

	# interest1 - compute compound interest 
	#    input: amount rate years 
	#    output: compounded value at the end of each year
	{ i=1 
	  while (i <= $3) {
	      printf("\t%.2f\n", $1 * (1 + $2) ^i) 
              i=i+1
          }
	} 

条件是跟在 while 后面，被小括号扩起来的表达式，循环体是跟在条件后面的，被大括号扩起来的两条语句。 在 printf 里面的\t 输出一个标准的制表符。^ 是求幂的操作， # 后面，直到行尾的文本是注释，这些内容会被awk 忽略，但是对于阅读程序，想弄清它是如何工作的人来说，有很大帮助。

你可以运行这个程序，输入三串数字，对应本金，利息，年数，然后来查看输出。例如下面显示了本金是1000，利息分别是 6% 和 12% ，存 5 年的情况。

	$ awk -f interest1 
	1000 .06 5
		1060.00 
		1123.60 
		1191.02 
		1262.48 
		1338.23
	1000 .12 5 
		1120.00
		1254.40 
		1404.93 
		1573.52 
		1762.34

for 语句

另外一个语句，for ，可以把测试条件，大多数循环里用到的增量，初始化，都压缩到一行里面。这里有一个用for 重写的上面本金利息的程序。


	# interest2 - compute compound interest
	# input: amount rate years
	# output: compounded value at the end of each year

	{for (i = 1; i <= $3; i = i + 1)
		 printf("\t%.2f\n", $1 * (1 + $2) ^ i)

  	}
 
i=1 作为初始化， 被先执行。 接下来的 i <= $3 是测试条件，如果是真的，作为循环体的printf 语句就会被执行。然后，作为增量的 i = i +1 就会在循环体执行之后，被执行， 然后，再次开始条件判断，循环被反复执行。这段代码更简洁一些，循环体是一条单独的语句，不需要用大括号括起来。

1.7 数组


awk 提供了数组用来存储一组相互关联的数据。awk 中的数组相当强大，我们在这里仅仅举一个简单的例子。下面的程序把输入的内容，逆序输出。第一个操作是把输入的行依次保存在 line 数组中连续的数组元素中，第一行存在 line[1] 中，第二行存在 line[2]中，等等。 END 操作使用了一个 while 语句，把数组中的行元素从最后一个到第一个，依次输出。

	# reverse - print input in reverse order by line 
	    {line[NR] = $0 } # remember each input line

	END { i = NR # print lines in reverse order 
	      while (i > 0) {
		print line[i]
		i=i-1
               }
            }

使用 emp.data 文件，输出如下：

	Susie 4.25 18 
	Mary 5.50 22 
	Mark 5.00 20 
	Kathy 4.00 10 
	Dan 3.75 0 
	Beth 4.00 0


1.8 常用的简短 awk 程序

尽管awk 可以写出一些非常复杂的程序，但迄今为止，我们看到的很多awk程序都不怎么复杂。这里收集了一些简短的程序，你可以使用或者得到一些启发。大多是上面语句的一些变化。

1. 显示输入的总行数

	END { print NR }

2. 显示输入的第10行

	NR == 10

3.显示输入的每一行的最后一个字段
        
       {print $NF}

4.显示输入的最后一行的最后一个字段

	{ field = $NF }
	END { print field }

5.显示每个大于4个字段的输入行

         NF　＞　４

6.显示最后一个字段的值大于４的输入行

	$NF > 4

7.显示出所有输入行的总的字段数

       {nf = nf + NF } END {print nf}

8. 显示出包含 Beth 的总行数

	/Beth/ {nlines = nlines + 1 }

	END { print nlines }

9.输出第一个字段的最大值，以及这个最大值所在的行。（假设 每一行的$1肯定都是一样的形式，可以用来比较，假设第一行的$1是数字，而第二行的$1是字母，就失去意义了。）

	$1 > max { max=$1; maxline = $0 }
	END	 { print max, maxline }

10. 输出每一个至少存在一个字段的非空行
	
	NF > 0

11. 输出每一个总长度大于80的行

	length($0) > 80

12.输出每一行的字段总数和这一行本身

	{ print NF, $0 }

13.把第一个字段和第二个字段，交互位置输出

	{ print $2, $1 }

14.输出第一个字段和第二个字段交互位置后的整行

	{temp=$1; $1 = $2; $2 = temp; print}

15.输出整行，但是把第一个字段替换为行号

	{ $1 = NR; print }

16.输出去掉第二个字段的整行

	{ $2 = ""; print }

17.把每一行的字段按逆序输出（最后一列变第一列，倒数第二列变第二列 ， 译者注）

	{for (i = NF; i > 0; i = i - 1) printf("%s ", $i) 
	printf("\n" )
	}

18. 输出每一行所有列的和

	{sum= 0 
         for (i = 1; i <= NF; i = i + 1) sum = sum + $i
	 print sum
	}

19. 输出所有行上所有列的总和

	{ for (i = 1; i <= NF; i = i + 1) sum = sum + $i }
    END { print sum }

20.输出每一行每一个数字字段的绝对值

      	{for (i = 1; i <= NF; i = i + 1) if ($i < 0) Si = -$i 
         print
	}	

1.9 下面有什么

你已经看到了awk程序的概貌。这一章的每一个程序，都是由 模式-行为 语句构成。awk对照模式检查每一个输入行，一旦模式匹配，就执行相对应的行为。 模式可以包含数字和字符串的比较，行为可以包含计算和格式化输出。除了自动读入你输入的行之外，awk还把每一行分割成字段。它还提供内置的数字变量和功能函数，也允许你自己来自定义。组合这些特性，很多有用的计算指令可以通过简短的程序被表达出来。许多其它语言需要指明的细节，在awk程序中被预先设置好了。

本书的余下部分详细说明了这些基本的理念。尽管实际中的例子要比这一章中出现的确实大一些，我们还是强烈建议你尽可能的开始写程序。这会让你熟悉这门语言，更容易的理解大一些的程序。对没有答案的问题做一些简单的尝试。你也应该通读整本书，每一个例子都表达了这个语言的一些东西，不是如何使用某个特性功能，就是如何创建一个有趣的程序。

==== 第二章 =====

AWK 语言

这一章大多数情况下是通过例子来解释了awk语言的构成元素。因为是完整的语言描述，材料都是细碎的，所有我们推荐你跳过这一章，在需要时，再回来检视这些细节。

最简单的awk程序是一串模式-行为语句：

    模式 {行为}
    模式 {行为}

在一些语句中，模式可以没有；在另外一些语句中，行为和它的大括号也可以没有。当awk检查了你的程序，确认它没有语法错误之后，它一次读入一行，逐个读入每一行，按模式的顺序去逐一匹配。如果一个模式匹配到了当前的输入行，它就会去执行相关的行为。

如果模式是空，就匹配每一行，所以，前面没有对应模式的行为，会在每一行上都被执行。如果一个模式-行为语句，仅仅有模式，（行为是空，）那么匹配这个模式的每一个输入行，将会被整行输出。

尽管在这一章的大多数情况里，措辞 “输入行” 和“记录”是同一意思的，在2.5节，我们将讨论多行记录，在多行记录中，一个记录包含数行。

在本章的第一节中描述了模式的细节，第二节开始通过描述表达式，赋值，控制流语句来描述行为的细节。余下的章节覆盖了函数定义，输入，输出，awk如何调用其它程序。大多数章节都包含一个主要特性的总结。

名为 countries 的输入文件

作为这一章中，很多awk程序的输入文件，我们将使用一个名为 countries 的文件。这个文件的每一行包含一个国家的名字,这个国家的面积，单位是千平方英里，这个国人口，单位是百万，在哪个大洲。数据是1984年的。前苏联（USSR）被随意的算作在亚洲。

这四列被用tab（制表符）隔开，" North America" 和 "South America" 中，含有一个单独的空格。 countries 文件包含下面的行：

        USSR		8649	275	    Asia
        Canada  	3852	25	    North America
        China		3705	1032	Asia
        USA		    3615	237	    North America   
        Brazil	    3286	134	    South America
        India		1267	746	    Asia
        Mexico	    762	    78	    North America
        France	    211	    55	    Europe
        Japan		144	    120	    Asia
        Germany	    96	    61	    Europe
        England	    94	    56	    Europe

在本章的剩余部分，在没有明确提到输入文件的情况下，都是使用countries 文件作为输入文件。

程序格式

模式-行为语句，以及行为中的若干语句，通常是通过分行来隔开的。但是，通过用分号来分隔，也可以把几个语句写在一行上。分号可以放在任何语句的结尾。

行为左边的大括号必须伴随它所对应的模式，两者要在同一行，行为余下的部分，包括右边的大括号，可以出现在接下来的数行上。

空行将被忽略；它们可以被插入到任何语句的前面或后面，来提高程序的可读性。空格和制表符（tab）可以被插入到操作和操作符周围，来增强可读性。

注释可以被插入到任何一行的结尾。一段注释以字符 # 开头，出现在一行的结尾，像这里的：

	{ print S1, $3 }     # print country name and population 

通过在想要中断的地方插入反斜线和另起一行，一个长语句可以跨越数行。

	{ print \ 
		$1,	# country name
		$2,	# area in thousands of square miles 
		$3 }	# population in millions

像上面这个例子，语句可以中断在注释之后，注释可以插入到每一个中断行的末尾。

在本书中，我们会使用几种格式风格，部分原因是为了举例说明其中的不同点，部分原因是不要让程序占用太多的行。像这一章中的这些短程序，格式不是大问题，但是一致性和可读性将使得比较长的程序易于管理。

2.1 模式

模式控制着行为的执行，当模式被匹配的时候，配套的行为就被执行了。这一章描述了六种模式，以及在那种条件下，它们会被匹配。

        === 模式总结 ===

1. BEGIN { 行为语句 } 

这里的行为，在全体输入行被读入之前将会被执行。

2. END { 行为语句 } 

这里的行为，将在所有的输入行被读入之后才会被执行。

3. 表达式 { 行为语句 } 

对于每一个输入行，只有满足这里的表达式的值是真，也就是非零，非空，这里的行为语句才会被执行。

4. / 正则表达式 / { 行为语句} 

当一个输入行中包含这里正则表达式所匹配的字符串时，这里的行为将会被执行。

5. 复合模式 { 行为语句 } 

复合模式就是用逻辑判断符  && (与), || (或), !(非), 连接起来的两个或多个模式，被包裹在一对圆括号中。只有对于一个输入行，这个复合模式最终的逻辑运算结果是真，行为语句才会被执行。

6.模式1， 模式2，{ 行为语句 } 

系列模式匹配，对于输入行来说，第一行匹配模式1，然后下一行匹配模式2，这时，行为语句会在第一行和下一行上都执行。

BEGIN 和 END 模式不能和其它模式组合在一起。一个系列模式不能作为其它模式的一部分。BEGIN 和 END 模式是后面必须有行为语句的模式。

BEGIN 和 END 模式

BEGIN 和 END 模式 不需要匹配任何输入行，相反，在awk 读入任何语句之前，BEGIN 对应的行为就被执行了。在awk读完所有语句之后，END对应的行为才会被执行。BEGIN 和 END 模式提供了获得初始化和总结的方法。BEGIN 和 END 模式不能和其它模式组合。如果出现了超过一个的BEDIN，按照它们出现的顺序，对应的行为会被依次执行。END的情况类似。 尽管不是必须的，我们一般把BEGIN 放到程序的开头，把END放到程序的最后。

一个常用的使用BEGIN 行为的情况是用来改变输入行的默认字段分隔符，这个分隔符被一个叫FS的内置变量控制。在默认情况下，字段是被空格或制表符分隔的，或者是空格和制表符一起分隔的。FS这个变量的值默认是空格。当字段的分隔符不是空格时，就要把FS变量设置为对应的字符。

下面的程序使用BEGIN 行为把字段分隔符设置为制表符（\t）并且在输出时放置了一个表头。第二个 printf 语句把输入的每一行都做了格式化，让它们对齐的排在表头下面。END对应的行为输出了总数（变量和表达式在第2.2章讨论）。 (当指定制表符作为分隔符时，需要注意：不像空格作为分隔符那样，几个连续的空格会被看做一个，当指定制表符作为分隔符时，两个连续的制表符，第一个会被认为是分隔符，第二个会被认为是有效的字段内容。译者注)

	# print countries with column headers and totals
	BEGIN { FS ="\t"	# make tab the field separator 
		printf("%10s %6s %5s %s\n\n",
			"COUNTRY",	"AREA",	" POP " , "CONTINENT")
	      }
	      { printf ("%10s %6d %5d	%s\n", $1, $2, $3, $4) 
		area = area + $2 
		pop = pop + $3
     	      }
	END   { printf ( "\n%10s %6d %5d\n", "TOTAL", area, pop) }

用 countries 文件作为输入，这个程序产生的输出结果如下：

	COUNTRY		AREA	POP	CONTINENT
 
	USSR 		8649 	275 	Asia 
	Canada		3852	25  	North America
	China 		3705 	1032 	Asia
	USA	    	3615	237 	North America
	Brazil		3286	134 	South America
	India 		1267 	746 	Asia 
	Mexico		762 	78 	    North America
	France		211	    55 	    Europe
	Japan 		144 	120 	Asia
	Germany		96	    61 	    Europe
	England		94	    56     	Europe

	 TOTAL    25681	  2819

用表达式做模式

像大多数语言一样，awk有丰富的表达式来描绘数字计算指令。和许多语言不同，awk也拥有很多表达式来描述字符串操作。贯穿本书，字符串这个术语意味着一串零或其它的字符。它们可以被存储在变量里面，或者逐个出现，作为一个常量，像  "" 或是 "Asia"。 字符串 ""  不包含任何字符，它被称作 空串 （null）。子串这个术语意味着包含在一个字符串中的一部分连续的零或其它字符。在所有的字符串中，空串可以作为长度是零的子串出现在第一个字符之前，每对相邻的字符之间，以及最后一个字符之后。






































































