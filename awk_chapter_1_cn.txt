$ awk '$3 == 0 { print $1 } 
Beth	4.00	0 
Beth 
Dan	3.75	0
Dan 
Kathy	3.75	10 
Kathy	3.75	0 
Kathy
...

粗体字是计算机回应显示。

用awk非常容易尝试这种行为：先输入你的awk程序，然后输入你的数据，然后看看发生了什么。我们再次鼓励你尝试这个例子并且尝试各种变化。

注意一下，这个程序是在命令行上被单引号括起来的。类似于“$” 这种shell提示符，可以用来协助程序大于一行的输入。（这句话的意思应该是指，当awk程序本身大于一行，进行多行输入时，前面的类似于 $ 这种提示符会相应的变化）

这种安排方式对于短小的程序（只有几行）是比较方便的。如果awk程序写的很长，那么把它写入一个叫 “progfile”的文件里面，然后在命令行上调用，更方便些。

	awk -f progfile	optional list of input files 	

-f 选项提示awk从一个指定的“progfile”文件里面获取程序的内容，在这里，“progfile”可以写成任何文件名。


错误说明

如果你在awk程序里面犯了一个错误，awk就会给你提示一个诊断信息。例如，如果你输错了一个大括号，像这样的：

	awk '$3 == 0 [ print $1 }' emp.data

你就会得到这样一个信息：

	awk: syntax error at source line 1 
	context is
		$3==0>>> [<<< 
		extra } 
		missing  ]
	awk: bailing out at source line 1

"Syntax error" 意味着你犯了一个语法错误，它被检测出来了，位于 >>> <<< 之间的位置。 "Bailing out"意味着没有尝试修复。有时候，你可以从错误报告中得到更多的提示，如错误匹配的引号，大括号等。

由于语法错误，awk没有试图去执行这个程序。但是，有些错误，只有在你的程序已经运行了，才会被检测到。例如，你试图用一个数去除0，awk就会停止处理，然后报告一个行号，这个行号就是程序里面试图进行这个除法的那一行。

=====================

1.2 简单输出

这一章的其余部分，集合了一些处理上面提到的emp.data文件的短小，典型的awk程序。我们将简短的解释它们是如何运行的。这些例子蕴含了主要的，有用的操作，这些操作是使用awk非常容易完成的：打印一些字段，选择输入，转换数据。我们在这儿并没有演示用awk的所有手段可以做的全部事情，或是特定事情的大量细节。但是，当你读完这一章，你的收获会相当多，而且你会发现读后面的章节更容易了。

我们通常仅显示程序，而不是整个的命令行。在每个例子里，就像上面演示的一样，给出的程序要用单引号括起来，作为awk命令的第一个参数。或者，把它放到一个文件里面，让awk用上面的 -f 选项调用它。

在awk里面，仅仅有两种类型的数据：数字和字符串。emp.data文件就是这种信息的一个典型:包含单词和数字，这些单词和数字被空格或者tab隔开。

awk一次读入一行，然后把每一行用字段分开，默认情况下，在这里的字段是指包含字符的一个序列，这个序列里面不包含任何空格或tab。当前读入行的第一个字段被称为 $1，第二个字段被称为 $2 ......等等。当前的整行被称为 $0 。这一行到下一行，字段的数目可以发生变化。

通常，我们需要做的就是显示出每行的全部或者一些字段，也许，还要执行一些计算。这一章的程序都是这种样式的。

输出每一行：

如果一个行为没有指定模式，这个行为就会在所有输入的行上执行。下面这个语句将显示当前输入行本身，所以，程序是这样的：

	{ print }

这个语句将打印出所有输入到标准输出设备上。因为 $0 也表示整行：

	{ print $0 }

也会做同样的事情。

输出某些字段

在一个单独的输出语句中，可以有超过一个的字段被输出到同一行中。下面的程序会输出每个输入行的第一个和第三个字段。

	{ print $1, $3 } 

如果用 emp.data 文件作为输入，它产生的结果是

	Beth 0
	Dan 0
	Kathy 10
	Mark 20
	Mary 22
	Susie 18

================
在这个输出语句中，表达式的各部分被逗号分隔开。在默认情况下，被输出的字段间用一个空格分隔开，输出读入的每行，都会相应产生一个新行。这些默认的设置都是可以被修改的，我们将在第二章演示如何操作。

NF， 字段行号



在输出中放置文本

你可以在输出的字段中间，插入一些额外的单词或者某些计算结果

	{ print "total pay for", $1, "is", $2 * $3 }

会输出

	total pay for Beth is 0
	total pay for Dan is 0
	total pay for Kathy is 40
	total pay for Mark is 100
	total pay for Mary is 121
	total pay for Susie is 76.5

在这个输出语句中，被双引号括起来的文本，随着字段和计算结果被一同输出。

1.3 复杂输出

输出语句是为了快速和容易的输出而设计的。你可以随心所欲设置输出格式。你也许不得不使用 printf 语句。我们将在第2.4章节看到它，printf 几乎可以产生各种输出，但在这一章，我们仅仅显示一点它的能力。

对齐字段

printf 语句具有这种样式：

	printf(format, value1, value2, ••• , valueN,)

在这里，format 是一个字符串，其中包含的文本将被逐一输出，另外还包含一些后面的 value 输出时的格式说明。一个ges说明的形式就是一个 % 后面跟着几个字符，这些字符来控制后面的 value 输出时的格式。在 format 中，从左往右数，第一个格式说明是用来告知 format 后面的 value1 是如何输出的，第二个格式说明是告知 后面的value2 是如何输出的，依次等等。因此，在 format中指定的%开头的格式说明数量，要和后面被输出的value的个数一样。

这里有一个程序，它运用printf 为每个员工输出了总工资：

	{ printf("total pay for %s is $%.2f\n", $1, $2 * $3) } 

在这个printf语句中，包含了两个%开头的格式说明。

第一个格式说明 %s 表明它所对应的第一个输出值 $1 ，是一个字符串；第二个格式说明，%.2f 表明它所对应的第二个输出值 $2*$3 ，是一个小数点后面保留2位的数字。在这个格式说明之前有个$ ，美元符号，它被原样输出。双引号括起来的 format 部分的结尾是 \n ，代表另起一个新行，这个就会让随后的输出从一个新行开始。拿emp.data文件作为输入，这个程序产生的结果如下：

	total pay for Beth is $0.00 
	total pay for Dan is $0.00 
	total pay for Kathy is $40.00 
	total pay for Mark is $100.00 
	total pay for Mary is $121.00 
	total pay for Susie is $76.50

使用 printf，空格和新行不会自动产生，你必须自己手动创建。别忘了 \n 。

这是另外一个输出每个员工姓名和工资的程序：

	{ printf("%-8s $%6.2f\n", $1, $2 * $3) }

第一个格式说明，%-8s ,输出名字作为一个左测对齐的字符串，这个字符串的宽度固定为8个字符。 第2个格式 %6.2f ，输出有两位小数的工资数目，这个字段的宽度固定为6个字符(-8表示左侧对齐，没有- ，表示右侧对齐，译者注)。

	Beth     $  0.00
	Dan      $  0.00
	Kathy    $ 40.00
	Mark     $100.00
	Mary     $121.00
	Susie    $ 76.50

随着我们的进行，我们将演示更多的 printf 的例子，完整的说明在 2.4 章节。

对输出排序

假设，你想按照工资额的升序，打印每一位员工的所有数据。最简单的方法是使用awk，把工资额作为前缀，放到每一条员工记录的前面，然后，把运行出来的结果，传递给一个排序程序。在 Unix 下，命令行是这样的

	awk '{ printf("%-6.2f %s\n", $2 * $3, $0) }' emp.data | sort -n

利用管道的方式，把awk的输出结果传递到 sort 命令去， 产生的结果：

	0.00   Beth	4.00	0
	0.00   Dan	3.75	0
	40.00  Kathy	4.00	10
	76.50  Susie	4.25	18
	100.00 Mark	5.00	20
	121.00 Mary	5.50	22



注：原书的语句是%6.2f ，译者为了美观和验证左对齐，改为了%-6.2f  ，输出结果也相应修改了，见谅。  另外，原书中的 sort 命令没有参数，如果想要得到按数字排序的结果，需要加上 -n 参数。



这是测试















