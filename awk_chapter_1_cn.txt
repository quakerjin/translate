$ awk '$3 == 0 { print $1 } 
Beth	4.00	0 
Beth 
Dan	3.75	0
Dan 
Kathy	3.75	10 
Kathy	3.75	0 
Kathy
...

粗体字是计算机回应显示。

用awk非常容易尝试这种行为：先输入你的awk程序，然后输入你的数据，然后看看发生了什么。我们再次鼓励你尝试这个例子并且尝试各种变化。

注意一下，这个程序是在命令行上被单引号括起来的。类似于“$” 这种shell提示符，可以用来协助程序大于一行的输入。（这句话的意思应该是指，当awk程序本身大于一行，进行多行输入时，前面的类似于 $ 这种提示符会相应的变化）

这种安排方式对于短小的程序（只有几行）是比较方便的。如果awk程序写的很长，那么把它写入一个叫 “progfile”的文件里面，然后在命令行上调用，更方便些。

	awk -f progfile	optional list of input files 	

-f 选项提示awk从一个指定的“progfile”文件里面获取程序的内容，在这里，“progfile”可以写成任何文件名。


错误说明

如果你在awk程序里面犯了一个错误，awk就会给你提示一个诊断信息。例如，如果你输错了一个大括号，像这样的：

	awk '$3 == 0 [ print $1 }' emp.data

你就会得到这样一个信息：

	awk: syntax error at source line 1 
	context is
		$3==0>>> [<<< 
		extra } 
		missing  ]
	awk: bailing out at source line 1

"Syntax error" 意味着你犯了一个语法错误，它被检测出来了，位于 >>> <<< 之间的位置。 "Bailing out"意味着没有尝试修复。有时候，你可以从错误报告中得到更多的提示，如错误匹配的引号，大括号等。

由于语法错误，awk没有试图去执行这个程序。但是，有些错误，只有在你的程序已经运行了，才会被检测到。例如，你试图用一个数去除0，awk就会停止处理，然后报告一个行号，这个行号就是程序里面试图进行这个除法的那一行。

=====================

1.2 简单输出

这一章的其余部分，集合了一些处理上面提到的emp.data文件的短小，典型的awk程序。我们将简短的解释它们是如何运行的。这些例子蕴含了主要的，有用的操作，这些操作是使用awk非常容易完成的：打印一些字段，选择输入，转换数据。我们在这儿并没有演示用awk的所有手段可以做的全部事情，或是特定事情的大量细节。但是，当你读完这一章，你的收获会相当多，而且你会发现读后面的章节更容易了。

我们通常仅显示程序，而不是整个的命令行。在每个例子里，就像上面演示的一样，给出的程序要用单引号括起来，作为awk命令的第一个参数。或者，把它放到一个文件里面，让awk用上面的 -f 选项调用它。

在awk里面，仅仅有两种类型的数据：数字和字符串。emp.data文件就是这种信息的一个典型:包含单词和数字，这些单词和数字被空格或者tab隔开。

awk一次读入一行，然后把每一行用字段分开，默认情况下，在这里的字段是指包含字符的一个序列，这个序列里面不包含任何空格或tab。当前读入行的第一个字段被称为 $1，第二个字段被称为 $2 ......等等。当前的整行被称为 $0 。这一行到下一行，字段的数目可以发生变化。

通常，我们需要做的就是显示出每行的全部或者一些字段，也许，还要执行一些计算。这一章的程序都是这种样式的。

输出每一行：

如果一个行为没有指定模式，这个行为就会在所有输入的行上执行。下面这个语句将显示当前输入行本身，所以，程序是这样的：

	{ print }

这个语句将打印出所有输入到标准输出设备上。因为 $0 也表示整行：

	{ print $0 }

也会做同样的事情。

输出某些字段

在一个单独的输出语句中，可以有超过一个的字段被输出到同一行中。下面的程序会输出每个输入行的第一个和第三个字段。

	{ print $1, $3 } 

如果用 emp.data 文件作为输入，它产生的结果是

	Beth 0
	Dan 0
	Kathy 10
	Mark 20
	Mary 22
	Susie 18

================
在这个输出语句中，表达式的各部分被逗号分隔开。在默认情况下，被输出的字段间用一个空格分隔开，输出读入的每行，都会相应产生一个新行。这些默认的设置都是可以被修改的，我们将在第二章演示如何操作。

NF， 字段行号

也许上面这些让你感觉必须用 $1 ，$2 这种方式来引用字段，但其实，任何跟在$后面的表达式都可以用来表明字段数字；这种表达式经过演算，它的数值被用作表示字段数字。例如：awk会统计当前输入行的字段数，把这个数值存储在内建的 NF 变量里面。因此，下面的程序：

 	{ print NF, $1, $NF } 

将会输出每一行的字段数，第一个字段和最后一个字段的内容。


计算和输出

你可以利用字段的值做一些计算，并且把计算的结果输出。下面的程序：

	{ print $1, $2 * $3 } 

是一个典型的例子。这个程序输出每个员工的姓名和总的工资（时薪乘以小时数）：

	Beth 0 
	Dan 0 
	Kathy 40 
	Mark 100 
	Mary 121 
	Susie 76.5

过一会我们将演示怎么让这个输出看起来更规整一些。

输出行号

awk提供了另外一个内置变量，叫NR，这个变量可以算出当前读入行的行号。我们可以使用 NR 和 $0 ，这样输出 emp.data的每一行时，可以在前面加上行号。

	{ print NR, $0 }

输出看起来是这样的：

	1 Beth	4.00	0
	2 Dan	3.75	0
	3 Kathy	4.00	10
	4 Mark	5.00	20
	5 Mary	5.50	22
	6 Susie	4.25	18


在输出中放置文本

你可以在输出的字段中间，插入一些额外的单词或者某些计算结果

	{ print "total pay for", $1, "is", $2 * $3 }

会输出

	total pay for Beth is 0
	total pay for Dan is 0
	total pay for Kathy is 40
	total pay for Mark is 100
	total pay for Mary is 121
	total pay for Susie is 76.5

在这个输出语句中，被双引号括起来的文本，随着字段和计算结果被一同输出。

1.3 复杂输出

输出语句是为了快速和容易的输出而设计的。你可以随心所欲设置输出格式。你也许不得不使用 printf 语句。我们将在第2.4章节看到它，printf 几乎可以产生各种输出，但在这一章，我们仅仅显示一点它的能力。

对齐字段

printf 语句具有这种样式：

	printf(format, value1, value2, ••• , valueN,)

在这里，format 是一个字符串，其中包含的文本将被逐一输出，另外还包含一些后面的 value 输出时的格式说明。一个ges说明的形式就是一个 % 后面跟着几个字符，这些字符来控制后面的 value 输出时的格式。在 format 中，从左往右数，第一个格式说明是用来告知 format 后面的 value1 是如何输出的，第二个格式说明是告知 后面的value2 是如何输出的，依次等等。因此，在 format中指定的%开头的格式说明数量，要和后面被输出的value的个数一样。

这里有一个程序，它运用printf 为每个员工输出了总工资：

	{ printf("total pay for %s is $%.2f\n", $1, $2 * $3) } 

在这个printf语句中，包含了两个%开头的格式说明。

第一个格式说明 %s 表明它所对应的第一个输出值 $1 ，是一个字符串；第二个格式说明，%.2f 表明它所对应的第二个输出值 $2*$3 ，是一个小数点后面保留2位的数字。在这个格式说明之前有个$ ，美元符号，它被原样输出。双引号括起来的 format 部分的结尾是 \n ，代表另起一个新行，这个就会让随后的输出从一个新行开始。拿emp.data文件作为输入，这个程序产生的结果如下：

	total pay for Beth is $0.00 
	total pay for Dan is $0.00 
	total pay for Kathy is $40.00 
	total pay for Mark is $100.00 
	total pay for Mary is $121.00 
	total pay for Susie is $76.50

使用 printf，空格和新行不会自动产生，你必须自己手动创建。别忘了 \n 。

这是另外一个输出每个员工姓名和工资的程序：

	{ printf("%-8s $%6.2f\n", $1, $2 * $3) }

第一个格式说明，%-8s ,输出名字作为一个左测对齐的字符串，这个字符串的宽度固定为8个字符。 第2个格式 %6.2f ，输出有两位小数的工资数目，这个字段的宽度固定为6个字符(-8表示左侧对齐，没有- ，表示右侧对齐，译者注)。

	Beth     $  0.00
	Dan      $  0.00
	Kathy    $ 40.00
	Mark     $100.00
	Mary     $121.00
	Susie    $ 76.50

随着我们的进行，我们将演示更多的 printf 的例子，完整的说明在 2.4 章节。

对输出排序

假设，你想按照工资额的升序，打印每一位员工的所有数据。最简单的方法是使用awk，把工资额作为前缀，放到每一条员工记录的前面，然后，把运行出来的结果，传递给一个排序程序。在 Unix 下，命令行是这样的

	awk '{ printf("%-6.2f %s\n", $2 * $3, $0) }' emp.data | sort -n

利用管道的方式，把awk的输出结果传递到 sort 命令去， 产生的结果：

	0.00   Beth	4.00	0
	0.00   Dan	3.75	0
	40.00  Kathy	4.00	10
	76.50  Susie	4.25	18
	100.00 Mark	5.00	20
	121.00 Mary	5.50	22



注：原书的语句是%6.2f ，译者为了美观和验证左对齐，改为了%-6.2f  ，输出结果也相应修改了，见谅。  另外，原书中的 sort 命令没有参数，如果想要得到按数字排序的结果，需要加上 -n 参数。

1.4  筛选

Awk 的模式匹配非常适合我们从输入的文件中筛选出我们需要的行，然后做进一步的处理。因为一个模式的后面如果不跟任何行为操作的话，将输出所有匹配这个模式的行，所以许多的awk程序就仅仅包含一个模式。这一章给出了一些有用的例子：

通过比较来筛选

这个程序使用了一个比较模式，筛选出了每小时工作等于或大于5美元的员工的记录，因此，设置比较第2个字段大于或等于5:

	$2 >= 5 

它会从 emp.data 文件中筛选出这些行：

	Mark	5.00	20 
	Mary	5.50	22

通过计算筛选

这个程序 ：

	$2 * $3 > 50 { printf("$%.2f for %s\n", $2 * $3, $1) } 

就可以输出总工资大于50美元的员工的名单。

	$100.00 for Mark 
	$121.00 for Mary 
	$76.50 for Susie

通过文本内容筛选

除了数字测试之外，你还能通过特定的单词或短语来筛选输入的行。下面的程序输出所有第一个字段是 Susie 的行。

	$1 == "Susie"

== 这个操作是做相等的测试。你也可以通过正则表达式来描绘出包含一组特定的字母，单词和短语的文本。下面的程序输出在任何位置包含 Susie 的行。

    /Susie/

输出是这一行：

	Susie	4.25	18

正则表达式对于描述复杂的模式非常有用；章节2.1包含了一个完整的讨论。

组合模式

模式可以通过圆括号，用  逻辑运算符 &&, || ,和 ! 组合起来，这些运算符表示 与 ，或 ，非。 这个程序：

	$2 >= 4 || $3 >= 20

将会输出第二个字段至少是4 或者第三个字段至少是20的行：

	Beth	4.00	0 
	Kathy	4.00	10 
	Mark	5.00	20 
	Mary	5.50	22 
	Susie	4.25	18

某些行满足两个条件，但只会被输出一次。 对比一下下面的这个有两个模式构成的程序：

	$2 >= 4 
	$3 >= 20

如果有些行两个条件都满足，那么这些行将被输出两次。

	Beth	4.00	0 
	Kathy	4.00	10 
	Mark	5.00	20 
	Mark	5.00	20 
	Mary	5.50	22 
	Mary	5.50	22 
	Susie	4.25	18

注意之处

	!($2 < 4 && $3 < 20)

这个程序将输出那些第2个字段并非小于4，或者第3个字段并非小于20的行，这个条件其实和上面组合模式的第一个是相等的，只是这个可读性差些。

数据验证

在现实的数据中，总会有些错误。对于检查数据的合理性，是否具有正确的格式这种被称为数据验证的工作来说，awk是一个优秀的工具。

数据验证本质是一种找错工作：输出不符合要求的行，不输出符合要求的行。


















