
第一章 AWK 入门教程

AWK 是一门简便的，富有表现力的语言，它被广泛的用来进行各种计算和数据处理任务。这一章是一篇设计成让你尽快开始写你自己程序的入门教程。第二章描述了整个awk语言，余下的章节展示了用awk在许多不同的领域解决问题。贯穿本书始终，我们一直在努力为你挑选出有用的，有趣儿的，有启发性的例子。

1.1 开始

有用的awk程序通常很短，仅仅一两行。假设你有一个名叫 emp.data 的文件，里面包含了你的员工的姓名，每小时应付的工资数，工作的小时数，一位员工的记录占一行，像下面这样：

	Beth  4.00	0 
	Dan   3.75	0 
	Kathy 4.00	10 
	Mark  5.00	20 
	Mary  5.50	22 
	Susie 4.25 	18

现在你想得到每一位有实际工作时间的，员工的姓名和工资数。这类工作是awk天生擅长的，所以很简单。只需要输入下面的命令：

	awk '$3> 0 { print$1, $2*$3 }'  emp.data 

你应该得到下面的输出：

	Kathy 40 
	Mark 100 
	Mary 121 
	Susie 76.5

这个程序告诉系统运行awk ，具体的awk 程序是被单引号括起来的，awk 需要的数据从输入文件 emp.data中获得。在单引号中的是一段完整的awk程序，它由一个 模式-行为 语句构成。 $3 > 0 ，这个是模式，它用来匹配输入的每一行的第三列，或者说第三个字段，如果这一行的第三个字段大于零，

	{ print $1, $2 * $3 }

这个行为将会输出第一个字段，以及第二和第三字段的乘积。

如果你想得到没有工作的员工的姓名，输入下面的命令行：

	awk '$3 == 0 { print $1 }' emp.data 

在这里的模式 ：$3 == 0 匹配到第三个字段是零的行，随后的行为 ：	{ print $1 } 输出这一行的第一个字段。

当你阅读本书时，试着运行和修改一下这些提供的程序。因为大多数程序都是简短的，你将很快明白awk是如何工作的。在一个unix系统上，上述两个命令在终端里面运行，可能是这样的：

	$ awk '$3 > 0 { print $1, $2 * $3 }' emp.data 
	Kathy 40 
	Mark 100 
	Mary 121
	Susie 76.5 
	$ awk '$3 == 0 { print $1 }' emp.data 
	Beth 
	Dan 
	$

在行开头的 $ 是系统提示符，这个可能和你的机器不一样。

AWK 程序的结构

让我们回头看看这些是如何进行的。在上面的命令行中，单引号之间的部分，是用awk语言写的程序。本章中的每一个awk程序都是一系列的一个或多个 模式-行为 语句。

	模式 { 行为 } 
	模式 { 行为 }
	...

awk 的基本操作就是一行接一行的扫描输入的一系列的行，在这些行中寻找和程序中任一模式相“匹配”的行，依靠模式中的问题，来实现准确的“匹配”。如果 $3 > 0 ，它意味着“条件是真”。

每一个输入的行，被每一个模式轮流测试。对于匹配的每一个模式，相对应的行为（可以包括多个步骤）会被执行。然后下一行被读入，从头到尾再被每一个模式轮流测试是否匹配。这个一直持续进行到所有的输入行都被读入过了。

上面的程序是一个模式和行为的典型例子。

	$3 == 0 { print $1 }

是一个单独的模式-行为语句；对于每一个读入的行，如果它的第三个字段是零，它的第一个字段将被输出。在一个模式-行为语句中，模式或者是行为可以被省略（但是不能两个都省略）。如果一个模式没有指定行为，例如下面的语句：

	$3 == 0

每一个匹配这个模式的行（在这里，就是每一个满足条件的行）都会被输出。这个程序应用到 emp.data文件中，将会输出第三列是零的两行。

	Beth 4.00 0 
	Dan  3.75 0

如果只有行为，没有模式，例如下面的例子：

	{ print $1 }

这个例子中的行为，将会把输入的每一行的第一个字段都输出。

因为模式和行为都是可选项，行为是通过一对闭合的大括号和模式加以区分的。

运行一个awk程序

有几种运行awk程序的方式。你可以通过：

	awk '程序' 输入文件（多个）

在每一个指定的输入文件上运行程序。例如，你可以输入：

	awk '$3 == 0 { print $1 }' file1 file2

把file1 ,file2 文件中的，每一个第三个字段是零的行，它的第一个字段都找出来。

你可以省略输入文件，在命令行上键入：

	awk  'program '

在这个例子中，awk将把程序应用到你接下来输入的每一行上，直到你输入一个文件结束信号（在unix系统下，是 ctrl-d ）。这里是一个在unix上的简单例子：

	$ awk '$3 == 0 { print $1 } 
	Beth	4.00	0 
	Beth 
	Dan	3.75	0
	Dan 
	Kathy	3.75	10 
	Kathy	3.75	0 
	Kathy
	...

粗体字是计算机回应显示。

用awk非常容易尝试这种行为：先输入你的awk程序，然后输入你的数据，然后看看发生了什么。我们再次鼓励你尝试这个例子并且尝试各种变化。

注意一下，这个程序是在命令行上被单引号括起来的。类似于“$” 这种shell提示符，可以用来协助程序大于一行的输入。（这句话的意思应该是指，当awk程序本身大于一行，进行多行输入时，前面的类似于 $ 这种提示符会相应的变化）

这种安排方式对于短小的程序（只有几行）是比较方便的。如果awk程序写的很长，那么把它写入一个叫 “progfile”的文件里面，然后在命令行上调用，更方便些。

	awk -f progfile	optional list of input files 	

-f 选项提示awk从一个指定的“progfile”文件里面获取程序的内容，在这里，“progfile”可以写成任何文件名。


错误说明

如果你在awk程序里面犯了一个错误，awk就会给你提示一个诊断信息。例如，如果你输错了一个大括号，像这样的：

	awk '$3 == 0 [ print $1 }' emp.data

你就会得到这样一个信息：

	awk: syntax error at source line 1 
	context is
		$3==0>>> [<<< 
		extra } 
		missing  ]
	awk: bailing out at source line 1

"Syntax error" 意味着你犯了一个语法错误，它被检测出来了，位于 >>> <<< 之间的位置。 "Bailing out"意味着没有尝试修复。有时候，你可以从错误报告中得到更多的提示，如错误匹配的引号，大括号等。

由于语法错误，awk没有试图去执行这个程序。但是，有些错误，只有在你的程序已经运行了，才会被检测到。例如，你试图用一个数去除0，awk就会停止处理，然后报告一个行号，这个行号就是程序里面试图进行这个除法的那一行。

=====================

1.2 简单输出

这一章的其余部分，集合了一些处理上面提到的emp.data文件的短小，典型的awk程序。我们将简短的解释它们是如何运行的。这些例子蕴含了主要的，有用的操作，这些操作是使用awk非常容易完成的：打印一些字段，选择输入，转换数据。我们在这儿并没有演示用awk的所有手段可以做的全部事情，或是特定事情的大量细节。但是，当你读完这一章，你的收获会相当多，而且你会发现读后面的章节更容易了。

我们通常仅显示程序，而不是整个的命令行。在每个例子里，就像上面演示的一样，给出的程序要用单引号括起来，作为awk命令的第一个参数。或者，把它放到一个文件里面，让awk用上面的 -f 选项调用它。

在awk里面，仅仅有两种类型的数据：数字和字符串。emp.data文件就是这种信息的一个典型:包含单词和数字，这些单词和数字被空格或者tab隔开。

awk一次读入一行，然后把每一行用字段分开，默认情况下，在这里的字段是指包含字符的一个序列，这个序列里面不包含任何空格或tab。当前读入行的第一个字段被称为 $1，第二个字段被称为 $2 ......等等。当前的整行被称为 $0 。这一行到下一行，字段的数目可以发生变化。

通常，我们需要做的就是显示出每行的全部或者一些字段，也许，还要执行一些计算。这一章的程序都是这种样式的。

输出每一行：

如果一个行为没有指定模式，这个行为就会在所有输入的行上执行。下面这个语句将显示当前输入行本身，所以，程序是这样的：

	{ print }

这个语句将打印出所有输入到标准输出设备上。因为 $0 也表示整行：

	{ print $0 }

也会做同样的事情。

输出某些字段

在一个单独的输出语句中，可以有超过一个的字段被输出到同一行中。下面的程序会输出每个输入行的第一个和第三个字段。

	{ print $1, $3 } 

如果用 emp.data 文件作为输入，它产生的结果是

	Beth 0
	Dan 0
	Kathy 10
	Mark 20
	Mary 22
	Susie 18

================
在这个输出语句中，表达式的各部分被逗号分隔开。在默认情况下，被输出的字段间用一个空格分隔开，输出读入的每行，都会相应产生一个新行。这些默认的设置都是可以被修改的，我们将在第二章演示如何操作。

NF， 字段行号

也许上面这些让你感觉必须用 $1 ，$2 这种方式来引用字段，但其实，任何跟在$后面的表达式都可以用来表明字段数字；这种表达式经过演算，它的数值被用作表示字段数字。例如：awk会统计当前输入行的字段数，把这个数值存储在内建的 NF 变量里面。因此，下面的程序：

 	{ print NF, $1, $NF } 

将会输出每一行的字段数，第一个字段和最后一个字段的内容。


计算和输出

你可以利用字段的值做一些计算，并且把计算的结果输出。下面的程序：

	{ print $1, $2 * $3 } 

是一个典型的例子。这个程序输出每个员工的姓名和总的工资（时薪乘以小时数）：

	Beth 0 
	Dan 0 
	Kathy 40 
	Mark 100 
	Mary 121 
	Susie 76.5

过一会我们将演示怎么让这个输出看起来更规整一些。

输出行号

awk提供了另外一个内置变量，叫NR，这个变量可以算出当前读入行的行号。我们可以使用 NR 和 $0 ，这样输出 emp.data的每一行时，可以在前面加上行号。

	{ print NR, $0 }

输出看起来是这样的：

	1 Beth	4.00	0
	2 Dan	3.75	0
	3 Kathy	4.00	10
	4 Mark	5.00	20
	5 Mary	5.50	22
	6 Susie	4.25	18


在输出中放置文本

你可以在输出的字段中间，插入一些额外的单词或者某些计算结果

	{ print "total pay for", $1, "is", $2 * $3 }

会输出

	total pay for Beth is 0
	total pay for Dan is 0
	total pay for Kathy is 40
	total pay for Mark is 100
	total pay for Mary is 121
	total pay for Susie is 76.5

在这个输出语句中，被双引号括起来的文本，随着字段和计算结果被一同输出。

1.3 复杂输出

输出语句是为了快速和容易的输出而设计的。你可以随心所欲设置输出格式。你也许不得不使用 printf 语句。我们将在第2.4章节看到它，printf 几乎可以产生各种输出，但在这一章，我们仅仅显示一点它的能力。

对齐字段

printf 语句具有这种样式：

	printf(format, value1, value2, ••• , valueN,)

在这里，format 是一个字符串，其中包含的文本将被逐一输出，另外还包含一些后面的 value 输出时的格式说明。一个ges说明的形式就是一个 % 后面跟着几个字符，这些字符来控制后面的 value 输出时的格式。在 format 中，从左往右数，第一个格式说明是用来告知 format 后面的 value1 是如何输出的，第二个格式说明是告知 后面的value2 是如何输出的，依次等等。因此，在 format中指定的%开头的格式说明数量，要和后面被输出的value的个数一样。

这里有一个程序，它运用printf 为每个员工输出了总工资：

	{ printf("total pay for %s is $%.2f\n", $1, $2 * $3) } 

在这个printf语句中，包含了两个%开头的格式说明。

第一个格式说明 %s 表明它所对应的第一个输出值 $1 ，是一个字符串；第二个格式说明，%.2f 表明它所对应的第二个输出值 $2*$3 ，是一个小数点后面保留2位的数字。在这个格式说明之前有个$ ，美元符号，它被原样输出。双引号括起来的 format 部分的结尾是 \n ，代表另起一个新行，这个就会让随后的输出从一个新行开始。拿emp.data文件作为输入，这个程序产生的结果如下：

	total pay for Beth is $0.00 
	total pay for Dan is $0.00 
	total pay for Kathy is $40.00 
	total pay for Mark is $100.00 
	total pay for Mary is $121.00 
	total pay for Susie is $76.50

使用 printf，空格和新行不会自动产生，你必须自己手动创建。别忘了 \n 。

这是另外一个输出每个员工姓名和工资的程序：

	{ printf("%-8s $%6.2f\n", $1, $2 * $3) }

第一个格式说明，%-8s ,输出名字作为一个左测对齐的字符串，这个字符串的宽度固定为8个字符。 第2个格式 %6.2f ，输出有两位小数的工资数目，这个字段的宽度固定为6个字符(-8表示左侧对齐，没有- ，表示右侧对齐，译者注)。

	Beth     $  0.00
	Dan      $  0.00
	Kathy    $ 40.00
	Mark     $100.00
	Mary     $121.00
	Susie    $ 76.50

随着我们的进行，我们将演示更多的 printf 的例子，完整的说明在 2.4 章节。

对输出排序

假设，你想按照工资额的升序，打印每一位员工的所有数据。最简单的方法是使用awk，把工资额作为前缀，放到每一条员工记录的前面，然后，把运行出来的结果，传递给一个排序程序。在 Unix 下，命令行是这样的

	awk '{ printf("%-6.2f %s\n", $2 * $3, $0) }' emp.data | sort -n

利用管道的方式，把awk的输出结果传递到 sort 命令去， 产生的结果：

	0.00   Beth	4.00	0
	0.00   Dan	3.75	0
	40.00  Kathy	4.00	10
	76.50  Susie	4.25	18
	100.00 Mark	5.00	20
	121.00 Mary	5.50	22



注：原书的语句是%6.2f ，译者为了美观和验证左对齐，改为了%-6.2f  ，输出结果也相应修改了，见谅。  另外，原书中的 sort 命令没有参数，如果想要得到按数字排序的结果，需要加上 -n 参数。

1.4  筛选

Awk 的模式匹配非常适合我们从输入的文件中筛选出我们需要的行，然后做进一步的处理。因为一个模式的后面如果不跟任何行为操作的话，将输出所有匹配这个模式的行，所以许多的awk程序就仅仅包含一个模式。这一章给出了一些有用的例子：

通过比较来筛选

这个程序使用了一个比较模式，筛选出了每小时工作等于或大于5美元的员工的记录，因此，设置比较第2个字段大于或等于5:

	$2 >= 5 

它会从 emp.data 文件中筛选出这些行：

	Mark	5.00	20 
	Mary	5.50	22

通过计算筛选

这个程序 ：

	$2 * $3 > 50 { printf("$%.2f for %s\n", $2 * $3, $1) } 

就可以输出总工资大于50美元的员工的名单。

	$100.00 for Mark 
	$121.00 for Mary 
	$76.50 for Susie

通过文本内容筛选

除了数字测试之外，你还能通过特定的单词或短语来筛选输入的行。下面的程序输出所有第一个字段是 Susie 的行。

	$1 == "Susie"

== 这个操作是做相等的测试。你也可以通过正则表达式来描绘出包含一组特定的字母，单词和短语的文本。下面的程序输出在任何位置包含 Susie 的行。

    /Susie/

输出是这一行：

	Susie	4.25	18

正则表达式对于描述复杂的模式非常有用；章节2.1包含了一个完整的讨论。

组合模式

模式可以通过圆括号，用  逻辑运算符 &&, || ,和 ! 组合起来，这些运算符表示 与 ，或 ，非。 这个程序：

	$2 >= 4 || $3 >= 20

将会输出第二个字段至少是4 或者第三个字段至少是20的行：

	Beth	4.00	0 
	Kathy	4.00	10 
	Mark	5.00	20 
	Mary	5.50	22 
	Susie	4.25	18

某些行满足两个条件，但只会被输出一次。 对比一下下面的这个有两个模式构成的程序：

	$2 >= 4 
	$3 >= 20

如果有些行两个条件都满足，那么这些行将被输出两次。

	Beth	4.00	0 
	Kathy	4.00	10 
	Mark	5.00	20 
	Mark	5.00	20 
	Mary	5.50	22 
	Mary	5.50	22 
	Susie	4.25	18

注意之处

	!($2 < 4 && $3 < 20)

这个程序将输出那些第2个字段并非小于4，或者第3个字段并非小于20的行，这个条件其实和上面组合模式的第一个是相等的，只是这个可读性差些。

数据验证

在现实的数据中，总会有些错误。对于检查数据的合理性，是否具有正确的格式这种被称为数据验证的工作来说，awk是一个优秀的工具。

数据验证本质是一种找错工作：输出不符合要求的行，不输出符合要求的行。下面的程序应用了5个比较模式，对emp.data文件的每一行进行五种合理性的检查。


	NF != 3   { print $0, "number of fields is not equal to 3" }
	$2 < 3.35 { print $0, "rate is below minimum wage" } 
	$2 > 10   { print $0, "rate exceeds $10 per hour" }
	$3 < 0    { print $0, "negative hours worked" }
	$3 > 60   { print $0, "too many hours worked" }

如果emp.data文件里面没有错误，那么这个程序就不会有任何输出。

BEGIN 和 END

特定的BEGIN 模式匹配第一个输入文件的第一行读入之前，特定的END模式匹配最后一个输入文件的最后一行被处理之后。下面的程序使用 BEGIN 打印出一个表头：

	BEGIN { print "NAME RATE HOURS"; print "" } 
	{ print }

 你可以利用分号分隔，把几个单行的语句放在同一行上。注意, print "" 将会输出一个空行，而 print 不是输出空行，而是输出当前的输入行 （所以，第二行的 print 语句将整行都输出了 ）。

1.5 利用 awk 进行计算

一系列的语句可以用新行或分号进行分隔。你已经看到了刚才那个单独的 print 语句的例子。本章节给出一些进行数值计算和字符串统计的语句例子。在这些语句中，你不仅可以使用内建的NF这类变量，而且可以自己定义一些变量，用来执行计算，存储数据这种操作。在awk里面，用户创建变量不需要声明。

计算总数

这个程序用一个 emp 的变量来统计工作超过15个小时的员工数：

	$3> 15{ emp=emp+1 } 
	END	{ print emp, "employees worked more than 15 hours" }

每当找到一个第三个字段大于15的行，预设的变量 emp 的数值就会增加1，用 emp.data 作为输入文件，这个程序的输出如下：

	3 employees worked more than 15 hours 

awk 的变量默认值为数字 0 ，  所以我们不需要初始化 emp 。

计算总数和平均值

我们可以利用内置的 NR 这个变量来得到员工的总数，这个变量保存着读入的行数，在所有的行都读入之后，它的值就是读入的行数。

	END { print NR, "employees" } 

输出结果是 ：

	6 employees 

下面这个程序利用NR 来计算平均工资值：

	{ pay =pay + $2 * $3 } 
	END { print NR, "employees"
	      print "total pay is", pay 
              print "average pay is", pay/NR
            }

第一个行为是统计出所有员工的工资总额。这个 END 总的输出如下：

	6 employees 
	total pay is 337.5 
	average pay is 56.25

很明显， printf 也可以产生近似的输出。这里有一个潜在的错误：在不常见的例子里面，NR 的值是零，程序试图用零做除数，因此会产生一个错误信息。

处理文本

awk 的强项之一，它具有一种能力：可以像大多数语言处理数字那样，方便的处理字符串。awk 的变量可以像处理数字一样有效的处理字符串。下面的程序可以找出每小时工资最高的员工。

	$2 > maxrate { maxrate =$2; maxemp =$1 } 
	END { print "highest hourly rate:", maxrate, "for", maxemp }

它的输出是：

	highest hourly rate: 5.50 for Mary

在这个程序中，maxrate 变量保存着一个数值，同时，maxemp 变量保存着一个字符串。（如果有几个员工都是最高工资，这个程序将找出表里的第一个）。

连接字符串

可以通过组合老的字符串来创造新的字符串，这个操作叫做连接。下面的程序：

	{ names = names $1 " " } 
	END { print names }

通过追加每一个员工的名字和一个空格到变量 names 里面，搜集了所有员工的名字，放到了一个单独的字符串里面。 通过END 操作，输出了names的值：

	Beth Dan Kathy Mark Mary Susie

在 awk 程序中，通过一个接一个写入字符串的值，表达了连接操作。 在每一个输入行中，程序的第一条语句连接了三个字符串：names 变量上一次的值，每行的第一个字段，一个空格；然后把这个连接的结果又赋值给了 names 变量。因此，在所有的行被读入之后，names 变量里面就有这样一个字符串，这个字符串里面包含着所有员工的名字，每个名字后面跟着一个空格。存储字符串的变量的初始值是null 字符串（里面没有存储任何字符）,因此，程序里的names 变量不需要初始化声明。

输出最后一行

尽管在END 的时候，NR依然保持着它的值，而$0 没有，这个程序：

	{ last = $0 }
	END { print last } 

是输出最后一行的一种方法：

	Susie	4.25	18 

内置的功能

我们已经看到了，awk提供了一些内置的变量，这些变量被经常的，有效的的使用，像字段的数目，输入的行号这些。于此类似，awk也有一些内置的功能用来计算一些有用的数据。除了像平方根，对数，随机数这种数学功能之外，还有一些操作文本的功能。其中之一是length，这个功能可以统计出一个字符串中字符的个数。 例如，下面这个程序可以计算出每个员工的名字的长度。

	{ print $1, length($1) } 

结果如下：

	Beth 4 
	Dan 3 
	Kathy 5 
	Mark 4 
	Mary 4 

统计行数，单词数和字符数

下面的程序使用 length ,NF, 和 NR 来统计输入的行数，单词数和字符数。方便起见，我们假设每个字段是一个单词。

	{ nc =nc + length($0) + 1 
	  nw =nw + NF
        }
   END	{ print NR, "lines,.., nw, "words,", nc, "Characters" } 

运行这个程序，emp.data 文件的统计结果：

	6 lines, 18 words, 77 characters

因为文本文件每行的末尾会有一个换行符存在，所以，我们在输入的每一行的字符统计里，都加了1，而 length($0) 里面不包含这个换行符（这个统计程序认为，每行不可见的换行符也要统计在字符里面，这个和linux 下的wc 程序一样，wc 程序统计的字符里面，也是包含每行的换行符的 -- 译者注）。

awk 提供了 if-else 语句来做判断，其他几个语句用来写循环，所有的这些模式都可以在C语言里面找到。它们仅仅能被用在 actions 部分。

If-Else 语句

下面的程序计算所有每小时工资超过6美元的员工，他们的工资总额和平均工资。它使用了 if 语句，来防止在计算平均工资的时候，出现 0 做除数的情况。

	$2 > 6 { n =n + 1; pay =pay + $2 * $3} 
	END    { if (n > 0)
		     print n, "employees, total pay is" , pay, 
                              "average pay is" , pay/n
		 else 
		     print "no employees are paid more than $6/hour"
               }

对 emp.data 文件的输出是：

	no employees are paid more than $6/hour

在 if-else 语句中，跟在if语句后面的条件作为评估，如果它是真的，if段的语句将被执行，否则，else 段的语句将被执行。注意，我们可以通过在每一行的后面加逗号，把一个长的语句分为几行来写。

while 语句

一个while 语句包含一个条件和一段语句。当每次判断条件是真的时候，这段语句就被重复执行一次。下面的程序根据给出的本金，利息和年数来计算出你每一年的存款总数，使用了 总额= 本金*（1 + 利息）^ 年数 这个计算公式。

	# interest1 - compute compound interest 
	#    input: amount rate years 
	#    output: compounded value at the end of each year
	{ i=1 
	  while (i <= $3) {
	      printf("\t%.2f\n", $1 * (1 + $2) ^i) 
              i=i+1
          }
	} 

条件是跟在 while 后面，被小括号扩起来的表达式，循环体是跟在条件后面的，被大括号扩起来的两条语句。 在 printf 里面的\t 输出一个标准的制表符。^ 是求幂的操作， # 后面，直到行尾的文本是注释，这些内容会被awk 忽略，但是对于阅读程序，想弄清它是如何工作的人来说，有很大帮助。

你可以运行这个程序，输入三串数字，对应本金，利息，年数，然后来查看输出。例如下面显示了本金是1000，利息分别是 6% 和 12% ，存 5 年的情况。

	$ awk -f interest1 
	1000 .06 5
		1060.00 
		1123.60 
		1191.02 
		1262.48 
		1338.23
	1000 .12 5 
		1120.00
		1254.40 
		1404.93 
		1573.52 
		1762.34

for 语句

另外一个语句，for ，可以把测试条件，大多数循环里用到的增量，初始化，都压缩到一行里面。这里有一个用for 重写的上面本金利息的程序。


	# interest2 - compute compound interest
	# input: amount rate years
	# output: compounded value at the end of each year

	{for (i = 1; i <= $3; i = i + 1)
		 printf("\t%.2f\n", $1 * (1 + $2) ^ i)

  	}
 
i=1 作为初始化， 被先执行。 接下来的 i <= $3 是测试条件，如果是真的，作为循环体的printf 语句就会被执行。然后，作为增量的 i = i +1 就会在循环体执行之后，被执行， 然后，再次开始条件判断，循环被反复执行。这段代码更简洁一些，循环体是一条单独的语句，不需要用大括号括起来。

1.7 数组


awk 提供了数组用来存储一组相互关联的数据。awk 中的数组相当强大，我们在这里仅仅举一个简单的例子。下面的程序把输入的内容，逆序输出。第一个操作是把输入的行依次保存在 line 数组中连续的数组元素中，第一行存在 line[1] 中，第二行存在 line[2]中，等等。 END 操作使用了一个 while 语句，把数组中的行元素从最后一个到第一个，依次输出。

	# reverse - print input in reverse order by line 
	    {line[NR] = $0 } # remember each input line

	END { i = NR # print lines in reverse order 
	      while (i > 0) {
		print line[i]
		i=i-1
               }
            }

使用 emp.data 文件，输出如下：

	Susie 4.25 18 
	Mary 5.50 22 
	Mark 5.00 20 
	Kathy 4.00 10 
	Dan 3.75 0 
	Beth 4.00 0


1.8 常用的简短 awk 程序

尽管awk 可以写出一些非常复杂的程序，但迄今为止，我们看到的很多awk程序都不怎么复杂。这里收集了一些简短的程序，你可以使用或者得到一些启发。大多是上面语句的一些变化。

1. 显示输入的总行数

	END { print NR }

2. 显示输入的第10行

	NR == 10

3.显示输入的每一行的最后一个字段
        
       {print $NF}

4.显示输入的最后一行的最后一个字段

	{ field = $NF }
	END { print field }

5.显示每个大于4个字段的输入行

         NF　＞　４

6.显示最后一个字段的值大于４的输入行

	$NF > 4

7.显示出所有输入行的总的字段数

       {nf = nf + NF } END {print nf}

8. 显示出包含 Beth 的总行数

	/Beth/ {nlines = nlines + 1 }

	END { print nlines }

9.输出第一个字段的最大值，以及这个最大值所在的行。（假设 每一行的$1肯定都是一样的形式，可以用来比较，假设第一行的$1是数字，而第二行的$1是字母，就失去意义了。）

	$1 > max { max=$1; maxline = $0 }
	END	 { print max, maxline }

10. 输出每一个至少存在一个字段的非空行
	
	NF > 0

11. 输出每一个总长度大于80的行

	length($0) > 80

12.输出每一行的字段总数和这一行本身

	{ print NF, $0 }

13.把第一个字段和第二个字段，交互位置输出

	{ print $2, $1 }

14.输出第一个字段和第二个字段交互位置后的整行

	{temp=$1; $1 = $2; $2 = temp; print}

15.输出整行，但是把第一个字段替换为行号

	{ $1 = NR; print }

16.输出去掉第二个字段的整行

	{ $2 = ""; print }

17.把每一行的字段按逆序输出（最后一列变第一列，倒数第二列变第二列 ， 译者注）

	{for (i = NF; i > 0; i = i - 1) printf("%s ", $i) 
	printf("\n" )
	}

18. 输出每一行所有列的和

	{sum= 0 
         for (i = 1; i <= NF; i = i + 1) sum = sum + $i
	 print sum
	}

19. 输出所有行上所有列的总和

	{ for (i = 1; i <= NF; i = i + 1) sum = sum + $i }
    END { print sum }

20.输出每一行每一个数字字段的绝对值

      	{for (i = 1; i <= NF; i = i + 1) if ($i < 0) Si = -$i 
         print
	}	

1.9 下面有什么

你已经看到了awk程序的概貌。这一章的每一个程序，都是由 模式-行为 语句构成。awk对照模式检查每一个输入行，一旦模式匹配，就执行相对应的行为。 模式可以包含数字和字符串的比较，行为可以包含计算和格式化输出。除了自动读入你输入的行之外，awk还把每一行分割成字段。它还提供内置的数字变量和功能函数，也允许你自己来自定义。组合这些特性，很多有用的计算指令可以通过简短的程序被表达出来。许多其它语言需要指明的细节，在awk程序中被预先设置好了。

本书的余下部分详细说明了这些基本的理念。尽管实际中的例子要比这一章中出现的确实大一些，我们还是强烈建议你尽可能的开始写程序。这会让你熟悉这门语言，更容易的理解大一些的程序。对没有答案的问题做一些简单的尝试。你也应该通读整本书，每一个例子都表达了这个语言的一些东西，不是如何使用某个特性功能，就是如何创建一个有趣的程序。

==== 第二章 =====

AWK 语言

这一章大多数情况下是通过例子来解释了awk语言的构成元素。因为是完整的语言描述，材料都是细碎的，所以我们推荐你跳过这一章，在需要时，再回来检视这些细节。

最简单的awk程序是一串模式-行为语句：

    模式 {行为}
    模式 {行为}

在一些语句中，模式可以没有；在另外一些语句中，行为和它的大括号也可以没有。当awk检查了你的程序，确认它没有语法错误之后，它一次读入一行，逐个读入每一行，按模式的顺序去逐一匹配。如果一个模式匹配到了当前的输入行，它就会去执行相关的行为。

如果模式是空，就匹配每一行，所以，前面没有对应模式的行为，会在每一行上都被执行。如果一个模式-行为语句，仅仅有模式，（行为是空，）那么匹配这个模式的每一个输入行，将会被整行输出。

尽管在这一章的大多数情况里，措辞 “输入行” 和“记录”是同一意思的，在2.5节，我们将讨论多行记录，在多行记录中，一个记录包含数行。

在本章的第一节中描述了模式的细节，第二节开始通过描述表达式，赋值，控制流语句来描述行为的细节。余下的章节覆盖了函数定义，输入，输出，awk如何调用其它程序。大多数章节都包含一个主要特性的总结。

名为 countries 的输入文件

作为这一章中，很多awk程序的输入文件，我们将使用一个名为 countries 的文件。这个文件的每一行包含一个国家的名字,这个国家的面积，单位是千平方英里，这个国人口，单位是百万，在哪个大洲。数据是1984年的。前苏联（USSR）被随意的算作在亚洲。

这四列被用tab（制表符）隔开，" North America" 和 "South America" 中，含有一个单独的空格。 countries 文件包含下面的行：

        USSR		8649	275	    Asia
        Canada  	3852	25	    North America
        China		3705	1032	Asia
        USA		    3615	237	    North America   
        Brazil	    3286	134	    South America
        India		1267	746	    Asia
        Mexico	    762	    78	    North America
        France	    211	    55	    Europe
        Japan		144	    120	    Asia
        Germany	    96	    61	    Europe
        England	    94	    56	    Europe

在本章的剩余部分，在没有明确提到输入文件的情况下，都是使用countries 文件作为输入文件。

程序格式

模式-行为语句，以及行为中的若干语句，通常是通过分行来隔开的。但是，通过用分号来分隔，也可以把几个语句写在一行上。分号可以放在任何语句的结尾。

行为左边的大括号必须伴随它所对应的模式，两者要在同一行，行为余下的部分，包括右边的大括号，可以出现在接下来的数行上。

空行将被忽略；它们可以被插入到任何语句的前面或后面，来提高程序的可读性。空格和制表符（tab）可以被插入到操作和操作符周围，来增强可读性。

注释可以被插入到任何一行的结尾。一段注释以字符 # 开头，出现在一行的结尾，像这里的：

	{ print S1, $3 }     # print country name and population 

通过在想要中断的地方插入反斜线和另起一行，一个长语句可以跨越数行。

	{ print \ 
		$1,	# country name
		$2,	# area in thousands of square miles 
		$3 }	# population in millions

像上面这个例子，语句可以中断在注释之后，注释可以插入到每一个中断行的末尾。

在本书中，我们会使用几种格式风格，部分原因是为了举例说明其中的不同点，部分原因是不要让程序占用太多的行。像这一章中的这些短程序，格式不是大问题，但是一致性和可读性将使得比较长的程序易于管理。

2.1 模式

模式控制着行为的执行，当模式被匹配的时候，配套的行为就被执行了。这一章描述了六种模式，以及在哪种条件下，它们会被匹配。

        === 模式总结 ===

1. BEGIN { 行为语句 } 

这里的行为，在全体输入行被读入之前将会被执行。

2. END { 行为语句 } 

这里的行为，将在所有的输入行被读入之后才会被执行。

3. 表达式 { 行为语句 } 

对于每一个输入行，只有满足这里的表达式的值是真，也就是非零，非空，这里的行为语句才会被执行。

4. / 正则表达式 / { 行为语句} 

当一个输入行中包含这里正则表达式所匹配的字符串时，这里的行为将会被执行。

5. 复合模式 { 行为语句 } 

复合模式就是用逻辑判断符  && (与), || (或), !(非), 连接起来的两个或多个模式，被包裹在一对圆括号中。只有对于一个输入行，这个复合模式最终的逻辑运算结果是真，行为语句才会被执行。

6.模式1， 模式2，{ 行为语句 } 

范围模式匹配，对于输入行来说，第一行匹配模式1，然后直到某一行匹配模式2，这时，行为语句会在第一行直到匹配模式2的行之间的行上都执行。

BEGIN 和 END 模式不能和其它模式组合在一起。一个系列模式不能作为其它模式的一部分。BEGIN 和 END 模式是后面必须有行为语句的模式。

BEGIN 和 END 模式

BEGIN 和 END 模式 不需要匹配任何输入行，相反，在awk 读入任何语句之前，BEGIN 对应的行为就被执行了。在awk读完所有语句之后，END对应的行为才会被执行。BEGIN 和 END 模式提供了获得初始化和总结的方法。BEGIN 和 END 模式不能和其它模式组合。如果出现了超过一个的BEDIN，按照它们出现的顺序，对应的行为会被依次执行。END的情况类似。 尽管不是必须的，我们一般把BEGIN 放到程序的开头，把END放到程序的最后。

一个常用的使用BEGIN 行为的情况是用来改变输入行的默认字段分隔符，这个分隔符被一个叫FS的内置变量控制。在默认情况下，字段是被空格或制表符分隔的，或者是空格和制表符一起分隔的。FS这个变量的值默认是空格。当字段的分隔符不是空格时，就要把FS变量设置为对应的字符。

下面的程序使用BEGIN 行为把字段分隔符设置为制表符（\t）并且在输出时放置了一个表头。第二个 printf 语句把输入的每一行都做了格式化，让它们对齐的排在表头下面。END对应的行为输出了总数（变量和表达式在第2.2章讨论）。 (当指定制表符作为分隔符时，需要注意：不像空格作为分隔符那样，几个连续的空格会被看做一个，当指定制表符作为分隔符时，两个连续的制表符，第一个会被认为是分隔符，第二个会被认为是有效的字段内容。译者注)

	# print countries with column headers and totals
	BEGIN { FS ="\t"	# make tab the field separator 
		printf("%10s %6s %5s %s\n\n",
			"COUNTRY",	"AREA",	" POP " , "CONTINENT")
	      }
	      { printf ("%10s %6d %5d	%s\n", $1, $2, $3, $4) 
		area = area + $2 
		pop = pop + $3
     	      }
	END   { printf ( "\n%10s %6d %5d\n", "TOTAL", area, pop) }

用 countries 文件作为输入，这个程序产生的输出结果如下：

	COUNTRY		AREA	POP	CONTINENT
 
	USSR 		8649 	275 	Asia 
	Canada		3852	25  	North America
	China 		3705 	1032 	Asia
	USA	    	3615	237 	North America
	Brazil		3286	134 	South America
	India 		1267 	746 	Asia 
	Mexico		762 	78 	    North America
	France		211	    55 	    Europe
	Japan 		144 	120 	Asia
	Germany		96	    61 	    Europe
	England		94	    56     	Europe

	 TOTAL    25681	  2819

用表达式做模式

像大多数语言一样，awk有丰富的表达式来描绘数字计算指令。和许多语言不同，awk也拥有很多表达式来描述字符串操作。贯穿本书，字符串这个术语意味着一串零或其它的字符。它们可以被存储在变量里面，或者逐个出现，作为一个常量，像  "" 或是 "Asia"。 字符串 ""  不包含任何字符，它被称作 空串 （null）。子串这个术语意味着包含在一个字符串中的一部分连续的零或其它字符。在所有的字符串中，空串可以作为长度是零的子串出现在第一个字符之前，每对相邻的字符之间，以及最后一个字符之后。

任何表达式均可以作为任何操作的操作数。如果一个表达式的结果是一个数值，但是，一个操作需要一个字符值，这个数值会被自动转换为字符串。类似的，当一个操作需要数值时，一个字符串也可以被转换为数值。

任何表达式都可以被用来作为一个模式。如果一个表达式被作为了模式，在当前输入行上，表达式的值不是零或者空值，就意味着，这个模式匹配上了当前行。典型的表达式模式是数值或者是字符之间的比较运算。一个比较表达式有六种比较运算符，或者两种字符串匹配操作 ~ （波浪号）和 !~ ，这两种将在下一章讨论。

这些运算符见下面的表 2-1 ：

表 2-1.  比较运算符

	     运算符      含义
	 	    <	     小于 
		    <=     	 小于等于 
		    ==       等于 
		    !=       不等于 
		    >=       大于等于
		    >        大于
		    ~        匹配正则表达式 
		    !~       不匹配正则表达式

如果模式是一个比较表达式，像 NF > 10 ，如果当前输入行的字段数大于10，满足这个表达式，那么当前行就匹配上这个模式了。 

如果模式是一个算数值表达式，像 NF ，如果当前输入行的NF 值不是零，那么就匹配这个模式。

如果模式是一个字符串表达式，如果当前输入行的字符串值不是空，那么就匹配这个模式。

在关系比较中，如果两端都是数字，那么就进行数值比较。否则，（一端是数值，一端是字符，或者两端都是字符，译者注），数字将会被转换为字符串，然后进行字符串的比较。字符值将被按照机器码定义的顺序，逐个字符进行比较。最常见的是  ASCII 字符码的比较。根据 ASCII的顺序，如果一个字符排在另外一个字符之前，那么前一个字符就小于后一个字符。 例如 "Canada" < "China" 以及 "Asia"< "Asian" 。

这个模式：

	$3/$2 >= 0.5

将会把第三个字段除以第二个字段的值大于等于0.5的行筛选出来。而这个：

	$0 >= "M" 

会把以M，N，O ...等等开头的行筛选出来。例如：
	
	USSR   8649 275 Asia
	USA    3615 237	North America
	Mexico 762  78	North America

有时，比较操作的类型，不能单独通过表达式呈现的语法来决定出来。这个程序：

    $1 < $4

比较输入行的第一个和第四个字段，可以是数字比较，也可以是字符串比较。在这里，比较的类型依赖于这些字段的值，从一行到另一行也可以发生变化。在 countries 文件里，第一和第四字段总是字符串，所以，进行的都是字符串比较。输出如下：

	Canada  3852	25    North America
	Brazil  3286	134   South America
	Mexico  762	    78    North America
	England 94	    56    Europe

只有两个字段都是数字，才会进行数值比较。下面的例子：

	$2 < $3

（两端）具有相同的数据。

2.2章节包含了更完整的字符串，数值和表达式的讨论。

字符串匹配模式

awk提供一个叫正则表达式的字符串表达和匹配方法。正则表达式被广泛的用在 Unix 程序中，包括文本编辑器和shell 。有限的正则表达式形式也出现在像 MS-DOS 系统上，用通配符来表明一系列的文件名。

字符串匹配模式就是测试一个字符串中是否包含一个正则表达式匹配的子串。

最简单的正则表达式是一串字符或是数字，像 “Asia” ，它匹配它自身。把它转化为字符串匹配模式，仅仅需要把它用斜线括起来。

	/Asia/

当输入行中包含子串  Asia ，不管是它本身，还是长单词中的一部分像 Asian 或 Pan-Asiatic ，这个行就被匹配上了。

注意空格在正则表达式里是非常重要的，涉及到字符串匹配。

========== 字符串匹配模式 ==========

1. /正则表达式/
当前输入行中包含一个匹配正则表达式的子串，当前输入行就算匹配这个模式了。

2. 表达式 ~ /正则表达式/
当前行的表达式结果是一个字符串，这个字符串中包含一个匹配正则表达式的子串，当前行就算匹配。

3. 表达式 !~ /正则表达式/
当前行的表达式结果是一个字符串，这个字符串中不包含一个匹配正则表达式的子串，当前行就算匹配。


任何表达式都可以使用 /正则表达式/ 用于内容比较  ~ 和 !~ 。

=====================================

/ Asia /

仅仅匹配 Asia 两侧都有空格这种情况。

以上的模式都属于上面提到的三种字符串匹配模式之一。字母r 两侧有斜线这种形式也是正则表达式。

	/r/

这个模式匹配一个输入行中包含一个内容为 r 的子串。

其他两种类型的字符串匹配都使用了一个明确的运算符：

    表达式 ~ /r/
    表达式 !~ /r/

运算符 ~ 意味着匹配， ! ~ 运算符意味着不匹配。第一个模式表示在表达式得出的字符串值里包含正则表达式 r 时，就算匹配上了。第二个表示字符串里的不包含这个正则表达式子串。

匹配运算符的左侧常常是一个字段：这个模式

	$4 ~ /Asia/

表示去匹配所有输入行的第四个字段，是否含有Asia 这个子串，而

	$4 !~ /Asia/

匹配第四个字段不含有 Asia 的行。

注意：字符串匹配模式 

    /Asia/ 

是 	$0 ~ /Asia/ 这个匹配模式的简明写法。

正则表达式

正则表达式是描述和匹配字符的一种表达方法。像算术表达式，一个正则表达式是一个基本的表达式或者是使用运算符组合成的表达式。为了理解正则表达式的字符串匹配，我们需要理解字符串匹配的组合方法。

======= 正则表达式 =======

1.正则表达式元字符：

	\ ^ $ . [ ] | ( ) * + ?

2.基本的正则表达式如下：

无元字符的，例如 A ，它匹配自身。
一个特定的序列，用来匹配特定的符号：\t 匹配一个制表符 （看表 2-2）。
一个被引用的元字符，例如\* ，它匹配这个元字符的本意 （\* 就是表示 * ，译者注）
^  它匹配字符串的开头。
$  它匹配字符串的结尾。
.  它匹配任意的单个字符。
一个字符组 [ABC] 匹配 A ，B 或C 中的任意一个。
字符组可以使用简写：[A-Za-z] 匹配任意一个字母。
取反字符组：[^0-9] 匹配任意一个非数字的字符。

3. 下面是大一些的正则表达式组合：

二选一： A|B  匹配A或B 。
串联：AB 匹配A后面紧跟着B 。
重复： A* 匹配零个或多个A 。
正重复：A+ 匹配一个或多个A 。
零次或一次：A？匹配一个空串或者 A 。
括号：(r) 和 字符串 r 匹配的一样。

==============================

基本的正则表达式汇总在上面的表里。

这些字符：

	\ ^ $ . [ ] | ( ) * + ?

被称为元字符，因为它们有特殊的含义。一个由非元字符构成的正则表达式匹配它自身。因此，单个的字母或数字是匹配自身的基本的正则表达式。在正则表达式中，为了表达元字符本身的意思，在元字符前面放一个斜线。因此 ，正则表达式 \$ 匹配字符 $ 。如果一个字符前面有一个单独的 \ ，我们就说这个字符是被引用的。

在一个正则表达式中，一个没有被引用的脱字符 ^ ，匹配一个字符串的开头。一个没有被引用的美元符号 $ ,匹配一个字符串的结尾。一个没有被引用的 . 匹配任意单个的字符。

    ^C      匹配以大写C开头的字符串   
    C$      匹配以大写C结尾的字符串
    ^C$     匹配只有一个字母C构成的字符串
    ^.$     匹配任意只有一个字符构成的字符串
    ^...$   匹配由任意三个字符构成的字符串
    ...     匹配任何包含三个连续字符的字符串
    \.$     匹配任何以. 结尾的字符串

由一组被中括号括起来的字符构成的正则表达式叫字符组。它匹配中括号中的任意一个字符。例如，[AEIOU] 匹配 A , E , I , O 或者 U 中任意一个字符（仅匹配一个字符，译者注）。

一定范围的字符可以使用带连字号（ - ） 的字符组简要表达。在连字号左边的字符定义了范围的开始，右边的字符定义了范围的结束。因此，[0-9]匹配任意一个一位数字，[a-zA-Z][0-9] 表示任意一个字母后面跟着任意一个数字。没有左右的字符，一个连字号在字符组里就表示它自身。所以，这个字符组[+-] 和[-+] 都是匹配 一个 + 或者一个 -  。 [A-Za-z-]+ 这个字符组匹配所有含有连字号的单词。

在字符组中，如果 ^ 紧挨着出现在左中括号的后面 [^ ，表示匹配不在这个范围内的字符。因此，[^0-9] 匹配任意一个非数字的字符，[^a-zA-Z] 匹配任意一个非大写非小写字母的字符。

    ^[ABC]      匹配以A，或B，或C 开头的字符串       
    ^[^ABC]     匹配非A ，B， C开头的字符串
    [^ABC]      匹配除了A, B , C 的任意一个字符
    ^[^a-z]$    匹配任意一个字符的字符串，字符里面不能有小写字母。

在字符组中，除了引用字符 \ 和在开头的^ ，在两个字符之间的 - ，所有字符都表示它自身的意思。因此，[.]匹配一个点，  ^[^^] 匹配一个非 ^ 开头的字符串。

圆括号在正则表达式里面被用来指明组合是如何分组的。有两种正则表达式运算符 ：二选一和组合 。二选一操作符 | 被用来指明二选一：如果 r1 和 r2 是两个正则表达式，那么 r1 | r2 匹配 r1 所表达的字符串，或r2所表达的字符串。

没有明确的组合运算符。如果r1 和 r2 是两个正则表达式，那么 (r1)(r2) （（r1）和（r2）中间没有空格）匹配由 XY 构成的字符串，其中 X匹配r1 ,Y匹配r2 。如果正则表达式里面没有二选一运算符，r1和r2 外面的圆括号可以被省略。 这个正则表达式

    (Asian|European|North American) (male|female) (black|blue)bird 

匹配从 Asian male blackbird 到 North American female bluebird 的十二种组合。

符号 * ，+ ，和 ？ 是一元运算符，在正则表达式中用来说明重复情况。如果 r 是一个正则表达式，那么（r）* 匹配含有零个或多个连续的r 子串的字符串。（r）+ 匹配含有一个或多个连续的r 子串的字符串。（r）？ 匹配空串或仅含有一个r 子串的字符串。如果 r 是一个基本的正则表达式，圆括号可以被省略。

    B*          匹配空串，B 或 BB 等等	  
    AB*C        匹配AC或ABC 或者 ABBC 等等
    AB+C        匹配ABC 或 ABBC 或 ABBBC 等等
    ABB*C       也是匹配ABC 或 ABBC 或 ABBBC 等等
    AB?C        匹配AC或ABC
    [A-Z]+      匹配一个或多个大写字母的字符串
    (AB)+C      匹配ABC ， ABABC 或者 ABABABC 等等


在正则表达式中，二选一运算符为最低优先级，然后是组合运算，最后是重复运算符 * , + , ? 。在一个算术表达式中，先处理高等级运算符，再处理第等级运算符。依照这种约定运算，括号可以被省略：ad | cd 和 (ab)|(cd) 是等价的。 ^ab|cd*e$ 也和 (^ab)|(c(d*)e$) 是一样的。

为了结束我们的正则表达式讨论，这里有一些使用一元和二元运算符的，包含正则表达式的，有用的字符串匹配模式的例子。旁边给出了它们匹配的各种输入行。记住：如果当前输入行至少有一个子串匹配上 r ，那么字符匹配模式 /r/ 就匹配上了当前输入行。

    /^[0-9]$/ 
        匹配仅包含一个数字的输入行
    /^[0-9][0-9][0-9]$/ 
        匹配只包含三个数字的输入行
    /^(\+|-)?[0-9]+\.?[0-9]*$/ 
        可以有符号或小数的十进制数字
    /^[+-]?[0-9]+[.]?[0-9]*$/ 
        也是可以有符号或小数的十进制数字
    /^[+-]?([0-9]+[.]?[0-9]+|[.][0-9]+)([eE][+-]?[0-9]+)?$/ 
        可以有符号或指数的浮点数
    /^[A-Za-z][A-Za-z0-9]*$/
        以字母开头后面可以是字母或数字的字符串 （例如，awk 里面的变量名)
    /^[A-Za-z]$|^[A-Za-z][0-9]$/ 
        单个字母或者单个字母后面跟一个数字的字符串 (例如Basic 里面的变量名)
    /^[A-Za-z][0-9]?$/ 
        也是单个字母或者单个字母后面跟一个数字的字符串

因为+ 和 . 是元字符，在第三个例子中它们不得不在前面放置斜线来匹配它们本来的意思，这个斜线在字符组里面是不需要的。所以第四个例子显示了用另外一种方法来表示相同的数字。

任何被斜线括起来的正则表达式都可以作为右侧的匹配运算符，这个程序：

    $2 !~ /^[0-9]+$/ 

输出所有第二个字段不是一串数字的行。

在正则表达式和字符串中，awk 使用了某种特定的字符组合序列，叫转义序列，用它来表达某些无法直接表达的字符指令。例如： \n 是代表换行符,它只会出现在字符串和正则表达式里。\b 代表退格符，\t 代表制表符；\007 代表 ASCII 中的响铃字符，以及 \/ 代表 / 这个斜线。转义字符只在awk程序中才有转义的功能，在数据文件中，它们仅仅是一般的字符。表2-2显示了完整的转义字符列表：

            表2-2

===============================

    序列        含义

     \b         退格符  
     \f         换页
     \n         换行
     \r         回车
     \t         制表符
     \ddd       ddd 在这里是1位到三位八进制数字，每一位的值的范围是0到7 
     \c         用来表达c 这个字符的本义（例如 \\ 就是表示 \ 的意思。）

================================

表2-3汇总了正则表达式和匹配的字符串，操作符按照递增的顺序排列。

            表 2-3 正则表达式

====================================

    表达式              匹配              

     c                  匹配非元字符的c
     \c                 转义序列或者是字符c的本义        
     ^                  字符串的开头
     $                  字符串的结尾
     .                  任意字符
     [c1c2...]          在c1c2范围内的任意字符
     [^C1C2...]         不在c1c2范围内的任意字符
     [c1-c2]            在c1到c2范围内的任意字符
     [^c1-c2]           不在c1到c2范围内的任意字符
     r1|r2              匹配r1或匹配r2的字符串
     (r1)(r2)           匹配字符XY，其中X匹配r1，Y匹配r2
                            r1和r2匹配范围没有歧义的话，不需要括号来分隔
     (r)*               零个或多个连续匹配r的字符串
     (r)+               一个或多个连续匹配r的字符串
     (r)?               零个或一个连续匹配r的字符串
                            最基本的正则表达式不需要括号来分隔
     (r)                匹配r的字符串

=================================================

复合模式

复合模式是指通过括号和逻辑运算符 || (或), && (与), 以及 ! (非)，组合了其它模式的一个表达式。如果这个表达式的值在当前输入行上是真的话，就匹配上了当前行。下面的程序使用了&& （与）操作符，筛选出第四个字段是 Asia ，并且 第三个字段大于500的行。

    $4 == "Asia" && $3 > 500 
    
这个程序

    $4 == "Asia" || $4 == "Europe"

使用了 || 或这个运算符，筛选出第四个字段是 Asia 或 Europe 的行。而这个是一个字符串值的测试，另外一种写法是使用正则表达式的 二选一操作符 | ：

    $4 ~ /^(Asia|Europe)$/

（如果两个正则表达式匹配相同的字符串，就说这两个正则表达式是等价的。 现在测试一下你对正则表达式优先级的理解：这两个正则表达式  ^Asia|Europe$ 和 ^(Asia|Europe)$ 等价吗？ ）

如果在其它列里不会出现 Asia 或者 Europe ，这个模式可以写成下面这样:

    /Asia/ || /Europe/ 

|| 运算符是最低等级，然后是 && ，最后是 ! 。 && 和 || 运算符从左到右执行他们的运算；一旦真值或假值被判断出来，运算就会停止。 

范围模式

范围模式包含两个被逗号分开的模式，像这样：

    pat1, pat2 

范围模式会匹配到从包含 pat1开始，到包含pat2结束的每一行，pat2 也可以和pat1 匹配到同一行,这样其实就只匹配上一行，（而不是数行了，译者注）。 例如下面的例子，这个模式：

    /Canada/, /USA/

匹配上的行中，开始第一行就是包含 Canada 的行，一直匹配到包含着 USA 的行才结束匹配。

当匹配从第一个模式开始后，如果随后一直没有匹配到第二个模式，那么从第一个模式开始到整个输入的末尾，都将被匹配上：

    /Europe/, /Africa/

输出：

    France	211	55	Europe 
    Japan   144 120 Asia 
    Germany 96	61	Europe 
    England 94	56	Europe

（因为 Africa 一直没有匹配到，所以，从 Europe 一直匹配到末尾了。 译者注 ）

在下面的例子中，FNR 是从当前输入文件读入的行数， FILENAME 是文件名自身，两者都是内建的变量，因此，下面的程序 ：

    FNR == 1, FNR == 5 { print FILENAME ": " $0 }

会用文件名做前缀，输出这个文件的前5行 。 另一种方法，这个程序也可以这样写：

    FNR <= 5 { print FILENAME ": " $0 }

范围模式不能作为任何其他模式的一部分 。

模式总结

表 2-4 总结了各种出现在模式-行为语句中的模式。

表 2-4 模式
==================================

     模式          例子            匹配

     BEGIN         BEGIN           在读入任何行之前
     END           END             在读入所有行之后
     表达式        $3 < 100        第三列数值小于100的行
     字符串匹配    /Asia/          包含字符串 Asia 的行
     复合表达式    $3 < 100&&      第三列数值小于100的行并且  
                   $4 == "Asia"    包含字符串 Asia 的行
     范围          NR==10, NR==20  在第10到第20行之间的行        


2.2 行为

在 模式-行为 语句中，模式决定了行为何时被执行。有时候，行为非常简单：一个单独的输出或者赋值。有时候，它可以是由换行符或分号分隔的一系列的语句。本章通过探讨表达式和控制流语句来谈论行为。随后的章节会出现用户定义功能和输入输出语句。

======================================

行为

语句中的行为可以包括：

表达式，常量，变量，赋值，功能调用，等等。

print 表达式列表
printf （格式，表达式列表）
if （表达式） 语句
if （表达式） 语句 else 语句
while （表达式） 语句
for （表达式， 表达式， 表达式）语句
for （变量 in 数组） 语句
do 语句 while （表达式）
break
continue
next
exit
exit 表达式
{ 语句}

======================================

表达式

我们从表达式开始，因为表达式是最简单的语句，大部分其他语句是由表达式的各种变化组成的。一个表达式是通过操作符来组合主要表达部分和其他表达部分来构成的。主要表达部分是主要的构建部分：它们包括常量，变量，参照数组，函数调用和内建变量，例如字段名。

我们从常量和变量开始讨论表达式。然后推进到组合表达式的操作。这些操作可以落实为5种类别：算术，比较，逻辑，条件和赋值。随后是内建的算术和字符串功能，在这一章最后安排的是数组的描述。

常量 

有两种类型的常量，字符串和数字。一个字符串常量就是在一对闭合的双引号标记中，被创建的一系列的字符。例如 "Asia" 或 "hello, world" 或 "" 。字符串常量也可以包含在表 2-2 列出的转义序列。

一个数字常量可以是一个整数，像 1127 ， 一个小数，像 3.14 ，或者是一个科学计数法，像  0.707E-1 。相同的数用不同的表达方法，还是具有一样的数值： 这些数字  1e6, 1.00E6, 10e5, 0 .1e7, 和 1000000 是数值等价的。所有这些数字（在awk 内部）都用依赖于机器精度的浮点数来存储。

变量

表达式可以包含几种变量：用户定义的，系统内建的，和字段。用户自定义变量的名字可以包含字母数字和下划线。但它不能用数字开头。所有的内建变量的名字都是大写字母。

一个变量有一个字符串或数字，或两种都行的值。因为变量的类型不用预先声明，awk是通过内容来判断变量的类型。在需要的时候，awk 会把一个字符串的值，转换为一个数值，反过来也一样。例如，在：

    $4 == "Asia" { print $1, 1000 * $2 }

如果$2 不是数值的话，将会被转换为数值, 并且 $1 和$4 原来不是字符串的话，将被转换为字符串。

一个没有被初始化的字符串，具有字符值""（空串）和数值 0 。

内建变量

表2-5列出了内建的变量。其中一些我们已经遇到过了。其他一些将在这章和后面的章节中被使用。这些变量可以在所有的表达式中使用，也可以被用户重设。每次读入新的文件，FILENAME 会被更新。每次读入新的记录，FNR ，NF和NR就会被更新。 此外，当$0 改变了，或者一个新的字段被创建了，NF 也会被重置。作为调用匹配功能的结果，RLENGTH 和 RSTART 也将改变。

表 2-5  内建变量

=======================================================

变量          含义                                默认值

ARGC         命令行参数个数                          -     
ARGV         命令行参数数组                          -
FILENAME     当前正在处理的文件的文件名              -
FNR          当前文件读入的行数                      -
FS           读入行的字段分隔符                      ""
NF           当前行的字段总数                        -
NR           当前读入的总行数                        -
OFMT         数字的输出格式                          "%.6g"
OFS          输出行的字段分隔符                      " "
ORS          输出行的分隔符                          " "   
RLENGTH      被match()函数匹配的字符串的长度         -   
RS           读入行的分隔符                          "\n"
RSTART       被match()函数匹配的字符串的起始位置     -
SUBSEP       数组中多个下标的分隔符                  "\034"


字段变量

当前输入行的字段被称为 $1 ，$2 直到 $NF ； $0 指向整行。字段变量也享有其他变量的属性。它们可以用来进行算术或字符串操作，也可以被赋值。因此，每个国家行中的第二列，可以重新写做被1000除以后的结果，单位从千平方公里变为百万平方公里。

        { $2 =$2 / 1000; print } 
   
也能把一个新的字符串赋值给这个字段：

    BEGIN                   {FS = OFS = "\t" $4}
    $4 == "North America"   {$4	== "NA"}
    $4 == "South America"   {$4	== "SA"}
                            {print }

在这个程序中，BEGIN 这段把控制输入字段的分隔符 FS 和控制输出字段的分隔符 OFS 都设置为 tab 了 。第四行的print 语句，将输出被上面语句修改过的$0 。这一点很重要：当 $0 被通过赋值或替换$1，$2 ...等等 改变以后，NF的值要重新计算；此外当 $1 ，$2 ...等等被改变以后，$0 要使用 OFS 重新构造输出的字段分隔。

字段也可以通过表达式来指定。例如，$(NF-1) 是指当前行的倒数第二个字段。 括号是必须的，$NF-1 表示比当前行最后一个字段的数值少1的一个数值。

一个字段变量可以指向一个不存在的字段，例如  $(NF+1) ，它的初始化值是一个空的字符串。通过给它赋值，可以创建一个新的字段。例如，下面的程序创建了包含人口密度的第5个字段：

    BEGIN	{ FS = OFS = "\t" } 
            {$5 = 1000 * $3 / $2 ; print }

(译者注： 如果创建 countires.txt 文件的时候，字段间的分隔符用的是空格，不是tab，这时，这段程序里面把 FS = OFS = "\t" 改为  OFS = "\t" ，就可以正常运行了。)

当需要的时候，任何数量的，被赋了空值的插入字段都可以创建。

从一行到另一行，字段的数量可能发生变化，但实际上这里有每行不超过100个字段的限制。

            表 2-5
===========================================

            表达式总结

1.主要的表达式组成部分：

数字和字符串常量，变量，字段，函数调用，数组元素等。

2.表达式中的连接操作符：

赋值操作符：= += -= *= /= %= ^=
条件操作符： ? :
逻辑操作符：||(或), && (与), !(非)
匹配操作符： ~ 和 !~
关系操作符： < <= == != > >=
连接操作符：（没有明确的操作）
算术操作符：+ - * / % ^ 
一元运算符：+ 和 -
递增和递减： ++ 和 -- （作为前缀和后缀）
分组：      括号


算术操作

awk提供了常用的 +, -, *, /, %, 和 ^ 算术操作。 % 操作是计算余数：x%y 表示求x被y除时的余数；如果x或y是负数的话，这个行为依赖于机制的定义。（通常只讲正整数取余数，对于负整数取余数，不同的计算机编程语言定义不一样，负整数取余数的例子： -2/9= -1 余数是7 。很多计算机编程语言实现了正整数取余，整数取余和实数取余。译者注 ）  ^ 操作是求幂： x^y 就是 x的y次方。所有的算术操作都是按浮点数进行的。

比较操作

比较表达式可以是关系操作或者是正则表达式匹配操作。关系操作是<, <=, == (等于), != (不等于), >=, 和 >。
正则表达式匹配操作是 ~ （匹配） !~ （不匹配）。表达式的结果是真，值为1 ，否则为0 。

类似的，匹配表达式如果匹配，值为1，不匹配，值为0 。所以

    $4 ~ /Asia/ 

如果当前行的第四个字段包括Asia 子字符串，这个表达式的值就是1，不包括，值就是0 。

逻辑操作

逻辑操作符 && （与） || （或） !（非） 通常被用来创建逻辑表达式。如果逻辑表达式的结果是真，这个表达式的值就是1，如果是假，值就是0 。计算一个逻辑操作时，非零或非空值的操作，被认为是真，否则被认为是假。被 && 或 || 分隔的表达式的逻辑操作，从左到右进行。一旦整个的表达式的值被判断出来，逻辑计算就结束了。这就意味着在 

    表达式1	&&	表达式2 

中，如果表达式1的值是假，那么表达式2的值就不会去判断。 而在

    表达式3 || 表达式4 

中，如果表达式3的值是真，表达式4就不会被判断。

在 && 和 || 的后面，可以插入新行。

条件表达式

一个条件表达式的形式是这样的:

    表达式1 ？表达式2 ：表达式3

首先，表达式1被判断。 如果它是真，因此，非零或非空，那么这个条件表达式的最后值就是表达式2的值；否则，（如果表达式1的值是假）那么整个表达式的最后值就是表达式3的值。表达式2和表达式3总是仅有一个需要被判断的。

下面的程序使用了一个条件表达式，来输出 $1 的倒数，或者如果$1 是0，输出一个警告：


    { print ($1 != 0 ? 1/$1 : "$1 is zero, line " NR) }

赋值操作

有7个可以用在表达式里，被称作赋值的操作。最简单的赋值表达式是这样：

    var = expr

在这里，var 是一个变量或字段名，expr 可以是任何表达式。例如，计算亚洲国家的个数和总人口数，我们可以这样写：

    $4 == "Asia" { pop = pop + $3; n = n + 1 } 
    END	         { print "Total population of the", n,
                    "Asian countries is", pop, "million."
                 }

应用到countries 文件上，程序产生的结果是：

    Total population of the 4 Asian countries is 2173 million.

第一行操作包含了两个赋值，一个是累计人口，另一个是统计国家的个数。变量不需要明确的初始化，一切事情都工作正常，因为，每个变量都被默认同时初始化为字符串""和数值 0 了。

在接下来这个 找出人口最多的国家 的程序中，我们也利用了默认初始化带来的便利：

    $3 > maxpop	{ maxpop = $3; country = $1	} 
    END	        {print "country with largest population:",
                    country, maxpop
                }

注意，虽然$3必须是正数，但无论如何，这个程序运行是正常的。

另外六个赋值操作是  +=, -=, *=, !=, %=, 和 ^= 。他们的含义是类似的： v op=e 和 v = v op e 有一样的效果，除非v 是那种仅仅一次的判断。下面的赋值：

    pop =pop + $3 

可以更简明的使用赋值操作 += ：

    pop += $3

这个语句和它更长的版本（这里指 pop =pop + $3 ，译者注）具有相同的效果 —— 左边的值是按照表达式右边的数值来增加的—— ，但是 +=  短一些，运行起来快一些。像另外一个例子：

    { $2 /= 1000; print }

第二列被1000除了之后，再输出整行。一个赋值就是一个表达式，它的值，就是它左边变量的新值。

因此，赋值可以被用在任何表达式中。在多重赋值中

    FS = OFS = "\t"

字段分隔符和输出字段分隔符都被设置为 tab 。赋值表达式也可以被包含在常见的测试语句中，像这样：

    if ((n = length($0)) > 0)	... 

增量和减量操作

这个赋值：

    n = n+1

通常写成 一元增量操作 ++n 或 n++ ，这个表示变量每次增加值是 1 。 前缀形式 ++n 表示在调用n的值之前进行增量，后缀形式 n++ 在调用之后增加n的值。这个造成了 ++ 在赋值语句中使用的不同点。如果 n 的初始值是1，赋值语句 i = ++n 把n 的值增大（1），然后把新值 2 赋值给 i ，而 赋值语句 i = n++ ，会把n的值增加，但是把原来的值1 赋值给i 。仅仅从n的增量讲， n++ 和 ++n 没有区别。 递减操作符 -- ，每次让变量递减1，工作方法（和++ ，译者注）相同 。

内建的算术功能

内建的数学函数列在表2-6 。这些功能可以在所有表达式中作为表达式的主体。在表中，x和y可以是任意表达式。

    表 2-6  内建的数学函数

=========================================
    函数            返回值

    atan2(y,x)      y除以x的反正切，范围在 -π 到 π
    cos(x)          x的余弦，x 为弧度
    exp(x)          x的幂函数，e的x次方
    int(x)          x的整数部分，
    log(x)          x的自然对数
    rand()          在0到1之间的随机数
    sin(x)          x的正弦，x 为弧度
    sqrt(x)         x的平方根
    srand(x)        x是rand()函数的种子

常用的常量可以用这些函数来进行计算，atan2(0,-1) 得到 π ，exp(1) 得到自然对数的底数 e 。计算x的十进制对数，使用 log(x)/log(10) 。

rand() 函数返回一个大于等于0，小于1的伪随机数 。 而 srand(x) 把随机数的开始点设置为x，调用 srand()(就是说不指定x的话，译者注)，会把当天当时的时间作为开始点。如果不调用srand()，在程序运行过程中，rand()每次都从相同的值开始生成随机数（这样的话，如果程序设计成在很短的时间内生成大量随机数，有可能出现很多重复的数。这样，所谓的随机数就不随机了。译者注）

赋值语句

    randint = int(n *rand()) + 1

设定 randint 为一个 1 到 n 之间的随机整数。这里我们使用了 int 函数，用来丢弃小数部分。下面的赋值语句

    x = int(x + 0.5)

在x是正数时，可以得到最接近x的整数值（四舍五入最接近x的值，译者注）。

字符串操作

只有一种字符串操作，串联。这种操作没有明确的操作符：字符串表达式通过写下常量，变量，字段，数组元素，函数值来创建，一个表达式接着另外一个。下面的程序：

    { print NR ":" $0 }

在行号和一个冒号的后面输出每一行，中间没有空格。数字NR被转换为它的字符串值（如果有必要，$0也会这样转换）；三个字符串组合在一起，作为结果被输出。

字符串作为正在表达式。

迄今为止，在我们所有的匹配表达式例子中，~ 和 !~ 右侧的操作数是一个用斜线封闭的正在表达式。但是，实际上，任何表达式都可以作为这些操作符右侧的操作数。AWK 会评估表达式，在必要的时候，把数值转换为字符串，把字符串解释为正则表达式。例如下面的程序：

    BEGIN	{ digits = "^[0-9]+$" } 
    $2 - digits

将会输出所有第二列是数字字符串的行（如果第二列不是数字字符串，无法进行减法运算，这里的减法运算，其实是来判断第二列是否是数字字符串的手段，译者注）。

因为表达式可以被组合而成，一个正则表达式可以用组件来建立。下面的程序将会把是有效浮点数的读入行输出出来：

    BEGIN { 
            sign = "[+-]?"
            decimal= "[0-9]+[.]?[0-9]*" 
            fraction= "[.][0-9]+" 
            exponent= "([eEl" sign "[0-9]+)?" 
            number= "^" sign "(" decimal "|" fraction ")" exponent "$"
    }
    $0 ~ number 

在匹配表达式时，引号引起来的字符串如 "^[ 0-9] +$" 和用斜线封闭的正则表达式 如/^[ 0-9] +$/是等价的。但是，这里有个例外。如果引号里面的某个字符正好是正在表达式的元字符，就需要一个额外的反斜线来表示它的意思是自身，而不是正则的元字符。 这里：

    $0 - /(\+|-)[0-9]+/
    and
    $0 - "(\\+|-)[0-9]+"

是等价的。

这个行为看起来有点神秘，它的神秘是因为在awk 的语法中，在双引号里面，第一层的反斜线保护会被脱去。如果一个元字符需要放置一个反斜线在它的前面，用来表示关闭它在正则表达式中的特殊含义，这时候反斜线的前面就还需要再加一个反斜线。如果在匹配操作的右侧是一个变量或字段变量，像这样：

    X ~ $1

这时，额外一级的反斜线就不需要了加在 $1 前面，因为在这里反斜线没有特殊的含义。

顺便说一下，它非常容易考验你对正则表达式的理解：程序

    $1 ~ $2
 
让你输入一个字符串和一个正则表达式；如果字符串匹配上正则表达式，它会回显这一行。

内建的字符串函数

awk 提供的内建字符串函数列在表 2-7中。在这张表里面，r 代表一个正则表达式（双引号包裹的字符串或者是一对斜线封闭的），s 和 t 代表字符串表达式，n 和 p 表示整数。

函数 index(s,t) 返回字符串t 在字符串s 最左边第一次出现的位置，如果t不在s里面，返回0 。字符串左侧第一个字符的位置是1 。 

    index("banana", "an") 

返回 2 。

函数 match(s,r) 找出，从最左侧开始，在字符串s中，匹配正则表达式 r 的最长的子字符串。它返回子字符串开始的位置（也叫索引，译者注），如果没有匹配的字符串，返回0 。也有内建的变量RSTART 返回这个索引（子字符串开始的位置，译者注）和内建变量 RLENGTH 返回这个匹配的字符串的长度。

函数 split(s,a,fs) 根据分隔符 fs ，把字符串 s 分隔为数组a，返回a数组中元素的个数。它将在本章的末尾，数组之后来讲解。

    表 2-7 内建的字符串函数
============================================

    函数                    描述

    gsub(r,s)               在$0全局范围内，用s替换r ，               
                            返回值是替换的次数
    gsub(r,s,t)             在字符串t的全局中，用s替换r，                 
                            返回值是替换的次数
    index(s,t)              返回（从左侧开始）字符串t在s中的位置，如果t不在s中返回0 。
    length(s)               返回字符串s中字符的个数
    match(s,r)              测试在字符串s中是否包含一个r匹配的子字符串
                            返回索引点或0；设置 RSTART 和 RLENGTH
    split(s,a)              用FS把字符串s分隔进数组a中，返回a中字段的个数
    split(s,a,fs)           用fs把字符串s分隔进数组a中，返回a中字段的个数
    sprintf(fmt,expr-list ) 用fmt格式列表定义后面 expr-list 列表中的表达式(str=sprintf("%d %s", 32, "                              years old"))
    sub(r,s)                用s替换$0中从最左侧开始，匹配r的最长可能的字符串
                            返回值是替换的次数
    sub(r,s,t)              用s替换t中从最左侧开始，匹配r的最长可能的字符串
                            返回值是替换的次数
    substr(s,p)             返回字符串s从位置p开始到末尾的字符串（p为数字，译者注）
    substr(s,p,n)           返回字符串s从位置p开始，长度为n的字符串

============================================

字符串函数 sprintf(format, expr1,expr2,expr3,...,exprn) 返回（但不是输出）一个按照 printf（format, expr1,expr2,expr3,...,exprn）格式化好的一系列的 expr1,expr2,...,exprn（sprintf和printf的区别是，printf 把结果直接输出，而 sprintf 把结果返回，保存在star=sprintf（...）里，指定的字符串 star中，译者注）。

因此，这个语句：

    x =sprintf("%10s %6d", $1, $2)

把$1 格式化为长度为10的字符串，$2格式化为长度为6位的小数，把格式化好的$1和$2保存在x中。 章节2.4中包含了字符的格式-转换的完整描述。

函数 sub和gsub模仿unix文本编辑器ed的替换命令。函数sub(r,s,t) 首先从t的最左侧开始查找匹配正则表达式r的最长的字符串，然后把找到的字符串用字符串s替换。像ed里面一样，“最左侧最长” 意味着从左侧开始，找到的第一个，（在匹配r的情况下，译者注）长度上尽可能的长（也就是正则匹配里面的贪婪模式，译者注）。

例如，以字符串banana为目标，anan 是正则表达式(an)+ 最左侧最长的匹配。与之相对，(an)*匹配上的是字母b之前的空字符串。

函数sub返回的是替换发生的次数。函数sub(r,s) 和函数sub(r,s,$0)同义。

函数gsub(r,s,t)是类似的，它会把在t中找到的，匹配r的，最左侧最长的，不重叠的字符串，一个接一个的用s都替换掉（g 这里是全局 global 的意思，意味着处处都要替换）。例如，这个程序：

    { qsub(/USA/, "United States"); print }

将会把所有读入的"USA"用"United States"替换掉。（在这个例子中，当$0改变时，字段和NF也会改变）。

    qsub(/ana/, "anda", "banana")

将会把 banana 替换为 bandana;匹配是不重复的。

在sub(r,s,t)和gsub(r,s,t)中，任何一个在s中出现的字符&都会被r匹配的子字符串替换掉。因此：

    gsub(/a/, "aba", "banana")

会把 banana 替换为 badanabanaba;下面的也一样

    gsub(/a/, "&b&", "banana")

在字串替换时，&的特殊含义可以通过在它前面加反斜线来关闭，像这样，\& 。

函数 substr(s,p) 返回字符串s从位置p开始到结尾的部分。如果使用substr(s,p,n)，只有从p开始的n个字符被返回；如果从p开始的到结尾的字符数少于n，那么从p开始完整的剩余部分被返回。例如，我们可以用下面的程序，把国家的名字缩写为它们的前三个字母：

    { $1 =substr($1, 1, 3); print $0 } 

会输出：

    uss 8649 275 Asia 
    Can 3852 25 North America 
    Chi 3705 1032 Asia 
    USA 3615 237 North America 
    Bra 3286 134 South America 
    Ind 1267 746 Asia 
    Mex 762 78 North America 
    Fra 211 55 Europe 
    Jap 144 120 Asia 
    Ger 96 61 Europe 
    Eng 94 56 Europe

设定了$1强迫awk去重新计算$0，因此字段的分隔符现在是空格（OFS的默认值），不再是 tab 了。

连接字符串仅仅就是把它们一个接另一个的写在表达式里。例如，在 countries 文件中，

    { s = s substr($1, 1, 3) " " } 
    END { print s }

将输出：

    USS Can Chi USA Bra Ind Mex Fra Jap Ger Eng

建立了一个分段的，初始时是零的，逐步增加的字符串 s 。（如果你对s结尾的空格感到困惑，用

    print substr(s, 1, length(s)-1) 

语句代替END里面 print s 语句，看看结果。

）

数字还是字符串？

一个表达式的值可以自动的从一个数字转化为字符串，反过来也一样，依赖于在它上面应用的操作。像这样的算术表达式：

    pop + $3

操作对象 pop 和 $3 必须是数字，所以，如果它们的值还不是数字的话，将会强制或被迫转化为数字。在赋值表达式：

    pop += $3

pop和$3必须是数字。在这样的字符串表达式：

    $1 $2

$1和$2必须是字符串才能被组合在一起。所以，如果需要，它们会被强制转化为字符串。

如果上下文的操作同时适用于数字和字符串，有特定规则。在赋值语句 v = e 中，变量v通过赋值获得了e的类型和内容。像这样的表达式：

    X == y

如果操作符两端都是数字类型，是数值比较，否则，任何是数字的一端会被强制转化为字符串，然后比较作为字符串的值。

让我们用下面涉及的字段比较来测试一下这个规则的含义：

    $1 == $2

这里，比较的类型依赖于字段包含的是数字还是字符,这个只能在程序运行时才能判断；读入的这一行和下一行，比较的类型可以不同。当awk在运行中创建的字段，它的类型自动设定为字符；此外，如果这个字段包含的内容代表一个数字，它也会给这个字段一个数字类型（这里的含义译者猜测是：awk 自己生成的字段默认都是字符类型，但如果这个字符能够表达一个数字，就会自动转化为数字类型，例如，如果awk自己生成的$3的值是123 ，按照默认，应该是字符类型，但是，123可以代表一个数字，所以，awk会把这个$3的类型设定为数字）。

例如，如果$1和$2都属于下列形式之一的话， $1 == $2 就会被作为数字进行成功比较。

    1   1.0     +1   1e0    0.1e+1  10E-1 001

因为这些值都是1的不同表现形式。但是，下面这些对会被作为字符串进行比较因此而失败。

    0    (null)
    0.0  (null) 
    0     0a
    1e500 1.0e500

在前三对中，第二列不是数字。最后一对会被作为字符进行比较，因为这两列代表的数太大了。

输出语句

    print $1

将输出第一个字段的字符串值；因此，输出和输入是相同的。

被创建的，未初始化的变量拥有数值0和字符串值"" 。 不存在的字段和明确为空的字段仅有字符串值 "" 。 它们没有数值。但是，当需要强制为数字时，它们就获得数值0 。在这一章的结尾我们将看到，数组下标是字符串。

这里有两种情况会强制一个表达式从一种类型转换到另一种。

    数字""      把一个数字和一个空字符串组合，会强制把这个数字转换为字符串
    字符串+0    让一个字符串和0相加，会把这个字符串强制转换为数字

因此，要在两列之间强制进行字符串比较，就要强制把其中一列转换为字符串：

    $1 "" == $2

要强制进行数值比较，就要强制把两列都变成数字。

 $1 + 0 == $2 + 0

这个工作不会顾及这些字段里面包含什么。

一个字符串的数值，是这个字符串前面看上去是数字的，最长的部分。因此

    BEGIN { print "1E2"+0, "12E"+0, "E12"+0, "1X2Y3"+0 }

输出

   100 12 0 1

一个数字的字符串值是用这个数字的输出格式OFMT转换后来进行计算的。OFMT也控制着下标数组连接，比较和创建的数字到字符串值。默认的OFMT值是 "%.6g" ，因此

    BEGIN { print 1E2 "", 12E-2 "", E12 "", 1.23456789 "" }

会输出：

    100 0.12 12 1.23457

可以通过给它赋新值来改变OFMT的默认值。例如，如果OFMT被改变为"%.2f" ,将会输出数字，将会强制进行数字比较，小数点后面将是2位数字。

    表 2-8 表达式运算

===========================================

运算名称                操作符           例子        例子的意思

赋值                    = += -= *=      x *=2         x = x*2
                        /= %= ^=
条件                    ?:              x?y:z        如果x为真，那么表达式值是y，否则是z
逻辑 或                 ||              x || y       如果x或y是真，值为1，否则为0
逻辑 与                 &&              x && y       如果x和y同时是真，值为1，否则为0    
数组成员是否存在        in              i in a       如果 a[i] 存在，值为1 ，否则为0
匹配                    ~ !~            $1 ~ /x/     如果第一个字段包含x，值为1 ，否则为0
相互关系                < <= == !=      X == y       如果x等于y，值为1，否则为0
                        >= >
组合                                    "a" "bc"     结果是"abc" ,这里没有明确的组合运算符
加 减                   + -             x + y        x加y的值    
乘 除 余数              * / %           x % y        x 除以y的余数
单项正负运算            + -             -x           x的相反数
逻辑 非                 !               !$1          如果$1的值为零或空，表达式的值为1，否则为0      
求幂                    ^               x^y          x的y次方   
递增，递减              ++ --           ++x x++      每次给x加1   
字段值                  $               $i+1         字段i 的值加1     
分组                    ( )             ($i)++       字段i 的值每次加1

运算符总结

可以出现在表达式中的运算符被汇总在表2-8中。可以通过这些运算符来操作常量，变量，字段名，数组元素，函数和表达式，来创造（需要的，译者注）表达式。

上面列出的操作符按照优先级递增来排列。优先级高的运算符在优先级低的运算符之前进行运算。这意味着，例如，在表达式中，乘法*在加法+之前进行。除了赋值运算符，条件运算符，求幂运算符之外，所有运算符都是向左组合的。向左关联性意味着相同优先级的操作是按照从左到右来进行的。因此 3-2-1 是 (3-2)-1, 不是 3-(2-1 ).

因为组合没有显式的操作符，可以巧妙的用括号来把需要组合的表达式扩起来。思考一下这个程序：

    $1 < 0 { print "abs($1) = " -$1 }

跟在 print 后面的表达式好像是组合，但实际上它是减法。这个程序：

    $1 < 0 { print "abs($1) = " ( -$1) } 
和
    $1 < 0 { print "abs($1) =" ,-$1 }

都是预期的操作（也就是说，后面两个的 -$1 都是组合，其中，最后一个和第一个的区别是，最后一个的-$1前面有个逗号，第一个没有。译者注）。

控制流语句

awk为一组组的语句提供了分支的功能，if - else 语句提供了条件选择 ，while ,for ,do 语句提供了循环功能。所有这些语句的功能都来自于C语言。

（在下面的例子中，译者注），在分支中的，单独的一个语句可以换成一堆语句。这堆语句可以用换行符或者分号来分隔开来。换行符可以放在任何左分支的后面，右分支的前面。

if-else 语句的形式

    if (表达式 )
        语句1 
    else
        语句2

else以及语句2 是可选项。在右括号后面，在语句1后面，在关键字 else 后面的换行符都是可选项。if ，else可以和语句1出现在同一行上，这时，如果语句1是一条单独的语句，那么它的结尾必须跟一个分号。

在一个 if-else 语句中，测试用的表达式被首先计算出来。 如果它的值是真，也就是说，非零或非空，语句1将会被执行。如果表达式的值是假，也就是说，是零或者是空，并且，else 及语句2存在，那么语句2将会被执行。

为了消除任何的含混不清，我们引入了这条规则：每个 else 都将和它前面最近的一个没有被（其他else 译者注）组合过的if 相结合。例如，在这个语句中的else :

    if (表达式1) if (表达式2) s=1; else s=2

将会和第二个if 相组合。（在 s=1 后面的分号是必须的，因为else 和它出现在同一行上。）

while 语句在条件是真的情况下，将反复执行一条语句。

============================================

===  控制流语句  ===

    {一些语句}
        语句组
    if(表达式) 语句
        如果表达式的值为真，执行语句
    if(表达式) 语句1 else 语句2
        如果表达式值为真，执行语句1 否则执行语句2
    while(表达式) 语句
        如果表达式的值一直为真，就反复执行语句
    for(表达式1 ;表达式2 ; 表达式3) 语句
        等价于 表达式1 ; while (表达式2) {语句; 表达式3}
    for (变量 in 数组) 语句
        依次把变量设置为数组中的每一个元素，然后执行语句
    do 语句 while (表达式)
        先执行语句，然后，如果表达式值为真，再反复执行
    break
        立刻跳出最内层的 while ，for 或 do 循环
    next
        开始主输入环的下一次循环
    exit
    exit 表达式
        如果 END 行为存在，立刻执行 END 的行为；然后跳出整个程序。
        返回表达式的值，作为程序的返回状态。(Unix程序都有返回值。译者注)

============================================

    while (表达式)
        语句

在右括号后面的换行符是可选的。在这个循环中，表达式的值被计算出来；如果它的值是真，语句被执行，表达式被再次计算。只要表达式的值是真，循环会一直重复。例如，这个程序将输出每一行的输入字段:

    {   i=1
        while (i <= NF) {
            print $i 
            i++
        }
    }

当 i 的值为 NF +1 时，循环会停止，那(NF+1，译者注)就是当循环退出后，i的值。

for 语句是 while 更通常的形式：

    for (expression 1 ; expression 2 ; expression 3 )
        statement

在右括号后面的换行符是可选的。下面这个和for 语句有相同的效果：

    expression 1
    while (expression2 ) {
        statement
        expression 3 
    }

所以

    for (i = 1; i <= NF; i++) 
        print $i

和上面的 while 语句一样循环所有的字段。在for 语句中，所有的三个表达式都是可选的。如果表达式2不存在，那么条件判断总是为真，所以，for ( ; ; ) 是一个无穷循环。

for 语句循环数组元素的样式，将在数组章节中描述。

do 语句有下面的形式

    do
    statement
    while (表达式)

在关键字 do 和 语句后面的换行符是可选的。如果while 和语句出现在同一行，而语句是一条单独的语句，那么这条语句的后面必须跟着分号。do循环先执行一次语句，然后，如果表达式的值是真，就一直反复执行语句。它和for 以及while语句有个决定性的区分方法：它判断结束条件在底部而不是顶部。所以，它至少会执行一次循环体的内容。

这里有两种语句会改变如何进行循环：break 和 countinue 。 break 语句会立刻退出从whil ,for 或do 中进行的循环。 continue 会引发开始下一次循环。它在while和do中作为测试表达式来执行，在for语句中，作为第三部分的表达式。

next 和 exit ，控制着awk 程序依次读入行的这个外部循环。next 引发awk来获取下一个读入行，然后从第一个模式-行为语句开始来进行模式匹配。 在 END 行为中，exit 语句会引发程序终结。在其他行为语句中，它的作用是让程序的行为变成好像已经读到了输入的结尾，不再进行输入的读取了，如果有END行为，就去执行了。

如果一个exit 语句包含一个表达式：

    exit 表达式

除非，被随后的错误或退出改写，它将引发awk将表达式的值作为程序的退出状态值。如果不包含表达式，退出状态值是0. 在包括unix的一些操作系统中，退出状态值可以被其他调用awk的程序检测到。

空语句

一个单独的分号表示一个空语句。在下面的程序中，for的循环体是一个空语句。

    BEGIN {FS = "\t" }
          {  for (i = 1; i <= NF && $i != ""; i++)
                 ;
             if (i <= NF)
                print
          }

这个程序将输出所有空字段的行（也就是所有的空行，译者注）。

数组

awk 提供一维数组来存储字符串和数字。数组和数组元素不需要被声明，甚至不需要指明一个数组中有多少个元素。类似于变量，数组元素只要被引用到，就可以立刻生成。作为初始值，他们拥有数值0和空字符串。

作为一个简单的例子，下面的语句:

    x[NR] = $0

把当前的输入行，赋值给x数组中的NR 这个元素。实际上，读入完整的输入到一个数组中是很容易的（也许想明白比较慢），然后用任何方便的顺序来处理它。例如，这个1.7章的程序的变体，把输入行按照相反的顺序输出：

        { x[NR] =$0 }
    END { for (i =NR; i > 0; i--) print x[i] }

第一个操作就是把每一个输入的行都依次记入数组x，使用行号作为数组下标；真正的输出工作在END语句中完成。

把awk数组和其他大部分语言区别开的特征是：它的数组下标是字符串。这个给了awk一个能力，组合内存的SNOBOL4 表，因为这个原因，awk中的数组被称为联合数组。

下面的程序，在数组pop中，累计了亚洲和欧洲的人口。END 行为输出了这两个大洲的总人口数。

    /Asia/       {pop["Asia"] += $3 }
    /Europe/     {pop["Europe"] += $3 }  
    END          {print "Asian population is",
                  pop["Asia"], "million."
                  print "European population is",
                  pop["Europe"], "million."
                  }

把这个程序对countries 文件运行，结果如下：

    Asian population is 2173 million. 
    European population is 172 million.

注意，数组下标是字符串常量 "Asia" 和 "Europe" 。如果我们写成 pop[Asia] 来代替 pop["Asia"], 表达式将使用变量 Asia 来作为数组下标，而变量Asia并没有初始化，其值转换到数组上就是 pop[""] 。

这个例子不是真的需要组合数组，因为这里只有两个元素，两个的名字都很清楚。假设把我们的任务替换为测定每个大洲的总人口。组合数组可以完美的适用这种集合。任何表达式都可以在数组参照里，作为数组下标，所以，

    pop[$4] += $3

使用当前输入行的，第四个字段的字符串值，作为pop数组的索引，它累加了第三个字段的值：

    BEGIN   {FS ="\t" } 
            {pop[$4] += $3 }
    END     {for (name in pop)
                print name, pop[name]
            }

数组pop的下标是大洲的名字；它的值是每个洲人口的累加。这段代码运行起来和洲的名字无关；从 countries 文件得到的输出是：

    North America 340 
    South America 134 
    Asia 2173
    Europe 172

最后一个程序是用 for 语句的形式来遍历一个数组全部的下标：

    for (变量 in 数组) 语句

这个循环中，随着变量被依次设为不同的数组下标所代表的值，后面的语句被一次次执行。下标被调用的顺序依赖于相互间的关系，如果通过后面的语句，有新的元素被添加到数组中， 结果是不可预知的。

你可以用一个表达式来判断一个特定的下标在数组中是否存在。

    subscript in A

如果 A[subscript]已经存在了，这个表达式的值是1，否则这个表达式的值是0 。
因此，为了测试 Africa 是否为数组pop的一个元素，你可以这样：

    if ("Africa" in pop) ...

这执行了一个条件测试，不会造成创建出 pop["Africa"]这种相反的结果。 如果你用下面的语句，就会自动创建出 pop["Africa"]这个数组元素：

    if (pop["Africa"] !="") ...

主要，这个不是测试数组 pop 中是否包含一个值为 "Africa" 的元素。

delete 语句

一个数组元素可以这样来删除：

    delete array[subscript]

例如，这个循环删除了数组pop中的所有元素

    for (i in pop) 
        delete pop[i]

split 函数

函数 split(str,arr,fs) 把 变量str表示的字符串分割成字段，然后把分割好的字段存到数组 arr中。 分割出的字段的数目，作为split函数的返回值。第三个参数 fs 的值，作为分割str时的字段分隔符。如果没有给出第三个参数，就使用FS来作为分隔符。两种状况下的规定，都是为了分割字段，这个在2.5章会被讨论。下面的函数用法：

    split("7/4/76", arr, "/")

使用/ 作为分隔符，把 7/4/76分割为三个字段，存储 7到arr["1"]中，4 到 arr["2"], 76 到 arr["3"]里面。

各种字符串都可以作为数组下标，但是，把数字用作字符，作为数组下标，似乎有点违反直觉。既然作为字符串来讲，1 和"1"的值是一样的， arr[1]和arr["1"]也是相同的。但是，注意 字符串01和1不相同，并且，字符串10 排在2的前面(这里的意思，应该是指 arr[10]在数组中的次序，排在arr[2]的前面)。

多维数组

awk不直接支持多维数组，但是它提供了一个使用一维数组模拟的方法。尽管，你可以写多维数组下标i,j或是s,p,q,r ，awk却会组合(包含它们中间的分隔符)这些下标的组件，综合成一个单独的下标，跳出了你写的多维下标。例如：

    for (i = 1; i <= 10; i++)
        for (j = 1; j <= 10; j++)
            arr[i, j] = 0

创建了一个有100个元素的数组，它的下标是1,1 ，1,2,这种。但是，在内部，这些下标是作为从1SUBSP1 ，1SUBSEP2 这种字符串来存储的。内部变量 SUBSEP 包含的值作为数组下标分隔符；它的默认值，不是一个逗号，而是"\034",这个默认值在一般文本中是不可见的。

对数组成员是多维数组下标的测试，使用了括号扩起来多维的列表，像这样

    if ((i,j) in arr) ...

但是，循环这种数组，你可以这样写

    for (k in arr) ...

如果需要访问单独的下标部分，可以使用split(k,x,SUBSEP) 。

数组元素不能自动的把它们自己变成一个个单独的数组。

2.3 用户自定义函数

作为内建函数的附加，一个awk程序可以包含用户自定义函数。 定义函数的语句形式是像这样的

    function name(parameter-list ) {
        statements
    }

一个函数定义可以出现在任何一个行为-模式语句能出现的地方。因此，一个awk程序的形式就是一系列的，被换行符或分号分隔开的，模式-行为语句和函数定义。

在一个函数定义中，函数体的左大括号后和右大括号前的换行符是可选项。参数列表是一系列的，被逗号分开的变量的名字；在函数体中，这些变量指向了函数被调用时的自变量。

在函数体中可以包含一个返回语句，它向调用者返回一个控制或者一个值。它的形式是这样的：

    return expression

表达式在这里是可选项，所以，它自己就是返回语句，但是，如果没有值被提供或者如果最后一个执行的语句没有返回值，那么，(函数的,译者注)返回值就是未定义的。

例如，这个计算它的参数中最大值的函数：

    function max(m, n) {
        return m > n ? m: n
    }

(在函数体中，译者注)变量m 和n 属于函数max ; 它们和任何程序中其它地方的同名的变量无关。

一个用户定义函数可以用在任何行为-模式语句和任何表达式中，或者在任何其他自定义函数体中。每一次使用就叫一次函数调用。如果一个用户定义函数在它自己的函数体中被自己调用，这个函数被称为递归。

例如，max 函数可以像这样被调用：

    { print max(S1,max(S2,S3)) } # print maximum of $1, $2, $3

    function max(m, n)  { 
        return m > n ? m : n
    }

在函数被调用的时候，在函数名和参数列表的左括号之间，不能有空格。

当一个函数被随着一个像$1这样的参数调用时，($1，译者注)就是一个普通的变量，函数被赋予一个这个变量值的拷贝，然后函数处理这份拷贝，不会改变变量本身。 这就意味着，在函数之外，函数不能影响变量的值。(用术语说，这种变量被称为"标量","通过数值"传递)。 但是，数组不能被拷贝，改变数组元素的值或者创建一个新的是可以的。(这个叫"通过引用"传递)。 函数名不能被用作参数。

再重复一次，在一个函数定义中，参数是函数的局部变量，它们的值仅仅维持在函数执行过程中，它们和程序中其他地方的同名变量没有关系。其它变量是全局变量； 如果一个变量不是通过参数列表被命名的，它就是显性的，可以在程序访问。

这就意味着，通过把一个变量包含在一个函数定义的参数列表的末尾，来保证这个变量仅仅是这个函数的私有变量，这种方法是可行的。任何一个在函数调用时，出现在参数列表中的，没有提供实际参数作用的变量，就是个初始化值为空的局部变量。这不是一个优雅的语言设计，但是它至少提供了必需的功能。我们在函数的实际参数和局部变量之间多放几个空格，这样显得比较突出。

2.4 输出

print 和 printf 语句产生输出。print 语句用在比较简单的输出，当比较详细的输出格式被要求的时候，使用 printf 。print 和 printf 的输出格式可以直接输出到文件中，或者输出到终端的管道的另一端。这些语句可以混合使用；输出的顺序是按照它们被生成的顺序来的。

============================================

        输出语句

print
    输出$0 到标准输出设备
print 表达式, 表达式, ...
    输出表达式的值，用OFS分隔，用ORS结尾
print 表达式, 表达式, ... > 文件名
    重定向输出到文件中，替代标准输出
print 表达式, 表达式, ... >> 文件名
    重定向输出，追加到文件的末尾，不覆盖以前的内容
print 表达式, 表达式, ... | 命令
    把输出作为命令的标准输入（也就是管道，译者注）
printf(格式，表达式，表达式，...)
printf(格式，表达式，表达式，...) > 文件名
printf(格式，表达式，表达式，...) >> 文件名
printf(格式，表达式，表达式，...) | 命令
    printf 命令和 print 命令类似，但是，第一个参数指定了输出格式
close(文件名) , close(命令)
    中断print 和文件名或命令之间的连接
system(命令)
    执行（括号中的）命令，从命令返回的状态就是这条(system，译者注)语句的值

printf 语句的参数列表不需要用括号扩起来。但是，如果参数列表中有表达式，或者printf语句里面包含了相关的操作，那么表达式或者参数列表必须用括号扩起来。 管道和system语句有可能在非unix系统中不能使用。

============================================

打印语句

打印语句有两种形式：

print 表达式1 , 表达式2 , ... , 表达式n
print(表达式1 , 表达式2 , ... , 表达式n)

这两种形式都会输出每个表达式的值，这些值通过每一个都后面跟着一个输出字段分隔符，被分隔开来。这条语句：

    print

是这条语句的缩写:

    print $0

为了打印一个空行，也就是只有一个换行符的行，使用

    print ""

上面第二种形式的print语句中，用括号扩起来了参数列表，像这样：

    print($1 ":", $2)

虽然两种形式的print语句产生同样的输出，但是，像我们看到的那样，如果参数中包含了相关操作符，括号就是必须的。

输出分隔符

输出字段分隔符和输出记录分隔符被存储在内置变量OFS和ORS中。OFS(默认，译者注)是一个空格，ORS(默认，译者注)是一个换行符。但是，这些值可以在任何时候被更改。例如，下面的程序使用一个冒号分隔每行的第一和第二字段，在第二字段之后，使用了两个换行符。

    BEGIN { OFS =":"; ORS ="\n\n" } 
    { print $1, $2 }

作为对比，

    { print $1 $2 }

输出中间没有字段分隔符的，第一和第二字段。因为，$1 $2 （中间可以有空格，译者注）构成了一个两个字段组成而成的字符串。

printf 语句

printf语句用来生成格式化的输出。除了 * 格式定义符不被支持之外，printf语句和C语言中的printf是类似的。像print一样，它也有无括号和有括号两种形式：

    printf 格式, 表达式1 , 表达式2 , ... , 表达式n 
    printf (格式, 表达式1 , 表达式2 , ... , 表达式n)

格式这个参数总是需要的；它是一个表达式，这个表达式的值包含了对后面参数列表中的表达式的值，如何按规定格式输出的，逐字说明。 在表2-9中，每一种规定格式都是用 % 开头， 以决定转换形式的字符结尾，可以包含三种变化：

    -       在这个字段中左对齐表达式的值
    width   按照宽度填充，前面的空白用0填充
    .prec   最大的字符串宽度，或者小数点右边的最大位数

表2-10 包含了规定格式，数值，和相应输出的一些例子。printf 产出的输出默认是不包括换行符的，除非你明确的把换行符写在后面。

输出到文件

重定向操作符 > 和 >> 把到标准输出的内容重新定向写入到文件中。下面的程序将会把第一个和第三个字段一起写入两个文件，如果第3个字段大于100时，写入bigpp文件（，小于等于100，写入smallpop文件，注意，这里不是第一个字段一个文件，第三个字段一个文件，而是当第三个字段大于100时，把第一，第三字段同时写入bigpp,小于等于100时，把第一，第三字段同时写入smallpop 。 译者注）其余的写入smallpop文件。


        TABLE 2-9. printf 格式控制字符
=========================================================

   字符            打印出的样式

   %c               ASCII 字符 
   %d               十进制整数  
   %e               [-]d.ddddddE[+-]dd 指数形式的浮点数      
   %f               [-]ddd.dddddd    浮点数 
   %g               可以是e或者是f ，由awk 自行选定， 
                    原则是没用的0，越少越好。  
   %o               无符号的，八进制整数        
   %s               字符串
   %x               无符号的，十六进制        
   %%               后面不跟参数时，将会输出一个 %;         
=========================================================

        TABLE 2-10. printf 指定输出的例子
=========================================================
        fmt         $1          printf("fmt", $1)

        %c          97           a        
        %d          97.5         97       
        %5d         97.5             97    
        %e          97.5         9.750000e+01   
        %f          97.5         97.500000   
        %7.2f       97.5            97.50    
        %g          97.5         97.5    
        %.6g        97.5         97.5    
        %o          97           141
        %06o        97           000141
        %x          97           61
        |%s|        January      |January|   
        |%10s|      January      |   January|
        |%-10s|     January      |January   |    
        |%.3s|      January      |Jan|    
        |%10.3s|    January      |       Jan|   
        |%-10.3s|   January      |Jan       |
        %%          January      %

============================================

    $3 > 100  { print S1, $3 >"bigpop" } 
    $3 <= 100 { print $1, $3 >"smallpop" }

这个是上面的那个 bigpop 和 smallpop 程序。

注意，两个文件必须用双引号扩起来。如果没有双引号，bigpop 和smallpop就是两个没有初始化的变量了。

文件名可以是变量，也可以是表达式:

    { print($1, $3) > ($3 > 100 ? "bigpop" : "smallpop") } 

可以做相同的工作，这个程序：

    { print > $1 }

可以把读入的每一行都写入到名字是第一个字段的文件中。

在print或是printf语句中，如果在参数列表中的表达式里面有关系操作符，表达式或者是参数列表都是需要用括号扩起来的。这个规则消除了重定向操作符 > 可能引发的潜在危险。 在这个程序：

    { print $1, $2 > $3 }

> 是一个重定向操作，因此，不是第二个表达式的一部分，所以，第一和第二字段的值被写入了名字为第三字段的文件里面。如果你希望第二个表达式里面包含 > 这个比较操作符，使用括号：

    { print $1, ($2 > $3) }

每次语句执行一遍，都会打开一次重定向文件，这一点也很重要，需要注意。每次print或者是printf语句会把更多的数据添加到打开的文件中。当使用重定向操作符 > 时，在任何输出数据写入到文件里面之前，这个文件会被初始化清零。如果用 >> 代替 > ，文件不会初始化清零；输出内容可以被追加到原来内容的后面。(这段话的意思是，如果使用 > ，每次写入前，都会把上一次的清除，以前写入的都无法保存。如果想一直追加数据，就要使用>> 来代替 > 译者注) 

输出到管道

在支持管道的操作系统中，也可以把输出直接传递进管道，来代替输出到一个文件中。这个语句:

    print | command

会把 print 语句的输出通过管道传递给 commad 命令。

假设我们想创建一个 大洲-人口 对，按照人口的多少逆序排列。下面的程序会依照第四个字段，每个不同的大洲，把第三个字段的人口值，分别累加到数组pop 中。 在END 行为段里，输出每一个大洲和它的人口，然后再把这个输出通过管道传递给sort 命令进行排序。

    # print continents and populations, sorted by population
    BEGIN { FS = "\t" }
    { pop[$4] += $3 }
    END { for (c in pop)
    printf("%15s\t%6d\n", c, pop[c]) | "sort -t'\t' +1rn"
    }

这个程序的输出是：

        Asia            2173 
        North America   340 
        Europe          172 
        South America   134

在Unix 系统中，写入标准错误文件，是管道的另外一个用法；代替了标准输出，输出被显示在用户的终端上。这里有几个写入标准错误文件的习惯用法：

    print message | "cat 1>&2" # 重定向 cat 到 标准错误输出 
    system( "echo '" message "' 1>&2") # 重定向 echo  到标准错误输出 
    print message > "/dev/tty" # 直接写到用户的终端上

尽管在我们的例子中，引号扩起来的都是字面意思上的字符串，但是命令行和文件名可以被指定使用任何的表达式。在调用的print语句，重定向输出的时候，文件或是管道可以通过它们的名字被判别出来，因此，上面程序中的管道的字面名字是：

    sort -t'\t' +1rn

正常情况下，在程序运行期间，一个文件或管道仅仅被创建或打开一次。如果一个文件或管道被明确的关闭然后再次被使用，这种情况就被称为重新打开。

关闭文件和管道

语句close(expr) 会关闭被expr代表的文件或是管道；表达式expr 的值所代表的字符串，就是第一次创建文件或管道时的名称。因此

    close("sort -t'\t' +1rn")

将会关闭上面打开的sort管道。

如果你想要写入一个文件，然后在同一程序的后面部分来读取它的内容，close 命令是必须的。这里还有系统定义级别的，可以在同一时间打开的文件和管道数目的限制。

2.5 输入

在awk程序中，提供了几种输入的方法。最常用的安排是把数据放到一个文件中，比如说叫data ,然后键入

    awk 'program' data

如果没有提供文件名，awk就从标准输入读取；因此，第二种常见的用法是从一个管道传递上一个输出到awk 程序。 例如，用egrep程序利用正则表达式筛选出需要的输入行，egrep程序做这个筛选比awk 快得多。因此我们这样使用命令：  

    egrep 'Asia' countries | awk 'program'

egrep 找出包含 Asia 的行，然后把它们传递给 awk 的程序，来进行后续的处理。

输入分解

内建变量FS的默认值是 " " ,也就是一个空格 . 当FS是这个值的时候，输入字段是用空格，或者tab(制表符) 来进行分隔的，并且，每行开头的空行或制表符会被忽略，因此，下面的文本，每一行都有相同的第一个字段：

    field1 
        field1
            field1    field2

但是，当FS是其它值的时候，每行开头空格或制表符就不会被忽略。

可以通过给内建变量FS指定不同的字符串，来对字段进行不同形式的划分。如果指定给FS的字符串长度超过了一个字符，或者说，它取自一个正则表达式，那么匹配这个正则表达式的，没有重复的，最左侧的，最长的，非空子字符串就是当前输入行的字段分隔符。例如：

    BEGIN { FS =",[ \t]*|[ \t]+" }

用一个逗号后面可以跟着空格或制表符（空格和制表符可以重复0次到多次），或者用空格或制表符（空格或制表符至少出现一次）没有逗号，来做字段分隔符。

当FS被设置为非空格的单个字符时，这个字符就作为字段分隔符。传统上用一个正则表达式的匹配结果来表示这个字段分隔符显得容易些：

    FS = "|"

用 | 作为一个字符分隔符。但是，注意，有些东西是间接表示的，像这个

    FS = "[ ]"

要求用一个空格作为字段分隔符。

FS也可以通过在命令行上用 -F 参数来设置。这个命令行：

    awk -F',[ \t]*|[ \t)+' 'program'

把字段分隔符设置成了和上面BEGIN 行为段一样的字符串。

多行记录

默认情况下，记录是用换行符来分隔的，所以，条目"行" 和 "记录" 正常情况下是同义的。但是，通过给内建的记录分隔变量RS指定新值，默认的记录分隔符可以用几种有限的方法来改变。如果RS被设置为一个空字符串，像

    BEGIN { RS = "" }

这样一来，每个记录就是用一个或多个连续的空行来进行分隔了，因此，一条记录就可能包含数行。通过赋值语句 RS = "\n" 把RS设回换行符，就可以恢复默认的行为。在拥有多行的记录中，无论FS是什么值，换行符总是字段分隔符之一。

一个通用的处理多行记录的用法是：

    BEGIN { RS = ""; FS = "\n" }

把记录分隔符设置为一个或多个连续的空行，把字段分隔符单独指定为换行符；因此，每行成为一个单独的字段。每个记录的长度是有限制的，一般大概是3000个字符。第三章包含了更多的关于如何处理多行记录的讨论。

getline 函数

getline函数可以被用来从当前输入，或者从一个文件，或者从管道来读取输入。利用它自身，getline取得下一条输入记录，在上面执行正常的字段分隔操作。它设置NF,NR,和FNR；如果有记录存在，它返回值1，如果已经到了文件的末尾，返回值0，如果有错误发生，返回 -1 （例如打开一个文件失败）。

表达式 getline x  读入下一条记录到变量x 中，(同时)NR 和FNR的值增加。不会做分隔字段的操作；NF的值没有被设置。

这个表达式

    getline <"file"

用从文件中读取来代替从当前输入中读取。这时对NR或者FNR 没有影响，但是，字段分隔的操作被执行，NF的值被设置出来了。

这个表达式

    getline x <"file "

从文件 file 中得到下一条记录，把它传递给变量 x ，不会进行分隔字段的操作，NF , NR , FNR的值也都没有动。

表 2-11 总结了 getline 函数的各种形式。 每个表达式的值就是指从 getline 返回的值。

作为一个例子，这个程序复制它的输入到它的输出，除了每一个像这种的行

    #include "filename"

这种行将会用文件 "filename" 的实际内容来替换。


        TABLE 2-11. GETLINE  函数

============================================

    表达式              相关改变的值

    getline             $0, NF, NR, FNR 
    getline var         var, NR, FNR
    getline <file       $0, NF
    getline var <file   var
    cmd | getline       $0,NF
    cmd | getline var   var
============================================

# include - replace #include "f" by contents of file f

    /^#include/ {
        gsub(/"/, "", $2)  # 这个函数的作用就是把 #include "filename" 中，"filename"外面的""去掉。
        while (getline x <$2 > 0)
            print x 
        next
    }
    { print }

利用管道，把另外一个命令的输出直接定向到getline 也是可以的。例如，这个语句：

    while ("who" | getline) 
        n++

执行Unix的程序who(就执行一次)，然后用管道把输出结果传递给 getline 。 who 的输出结果是当前登录的用户列表，每一次通过while 循环，来循环读入列表中的一行行，就会让变量n的值增加1，所以，当while循环最终完成，n的值就是用户的个数。

类似的，这个表达式

    "date" | getline d

利用管道把date命令的输出传递给变量d，因此，d被赋值为当前的日期。再次强调，在非Unix类系统中，输入管道可能不能使用。

在所有的调用getline的例子中，你可能已经意识到，如果文件不能被访问到，可能会返回一个错误。尽管这样写很诱人：

    while (getline <"file") ... # 危险的写法

如果 file 不存在，将会是一个无限的循环，因为file不存在，getline 返回值是-1 ，一个非零的值对while循环来说，就代表真。首选的写法是：

    while (getline <"file" > 0) ... # 安全的写法

这里，当getline返回1的时候，循环才会被执行。











