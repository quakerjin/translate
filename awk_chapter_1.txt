1	AN AWK TUTORIAL
Awk is a convenient and expressive programming language that can be applied to a wide variety of computing and data-manipulation tasks. This chapter is a tutorial, designed to let you start writing your own programs as quickly as possible. Chapter 2 describes the whole language, and the remaining chapters show how awk can be used to solve problems from many different areas. Throughout the book, we have tried to pick examples that you should find useful, interesting, and instructive.

1.1	Getting Started

Useful awk programs are often short, just a line or two. Suppose you have a file called emp.data that contains the name, pay rate in dollars per hour, and number of hours worked for your employees, one employee record per line, like this:

	Beth  4.00	0 
	Dan   3.75	0 
	Kathy 4.00	10 
	Mark  5.00	20 
	Mary  5.50	22 
	Susie 4.25 	18

Now you want to print the name and pay (rate times hours) for everyone who worked more than zero hours. This is the kind of job that awk is meant for, so it's easy. Just type this command line:

	awk '$3> 0 { print$1, $2*$3 }'  emp.data 

You should get this output:

	Kathy 40 
	Mark 100 
	Mary 121 
	Susie 76.5

This command line tells the system to run awk, using the program inside the

==============

quote characters, taking its data from the input file emp.data. The part inside the quotes is the complete awk program. It consists of a single pattern-action statement. The pattern, $3 > 0, matches every input line in which the third column, or field, is greater than zero, and the action

	{ print $1, $2 * $3 }

prints the first field and the product of the second and third fields of each matched line.

If you want to print the names of those employees who did not work, type this command line:

	awk '$3 == 0 { print $1 }' emp.data 

Here the pattern, $3 == 0, matches each line in which the third field is equal
to zero, and the action 

	{ print $1 }

prints its first field. 

As you read this book, try running and modifying the programs that are presented. Since most of the programs are short, you'll quickly get an understanding of how awk works. On a Unix system, the two transactions above would look like this on the terminal:

	$ awk '$3 > 0 { print $1, $2 * $3 }' emp.data 
	Kathy 40 
	Mark 100 
	Mary 121
	Susie 76.5 
	$ awk '$3 == 0 { print $1 }' emp.data 
	Beth 
	Dan 
	$

The $ at the beginning of a line is the prompt from the system; it may be different on your machine.

The Structure of an AWK Program

Let's step back a moment and look at what is going on. In the command lines above, the parts between the quote characters are programs written in the awk programming language. Each awk program in this chapter is a sequence of one or more pattern-action statements:

	pattern { action } 
	pattern { action }
	...

The basic operation of awk is to scan a sequence of input lines one after another, searching for lines that are matched by any of the patterns in the program. The precise meaning of the word "match" depends on the pattern in

=================

question; for patterns like $3 > 0, it means "the condition is true." 

Every input line is tested against each of the patterns in turn. For each pattern that matches, the corresponding action (which may involve multiple steps) is performed. Then the next line is read and the matching starts over. This continues until all the input has been read. 

The programs above are typical examples of patterns and actions.

	$3 == 0 { print $1 }

is a single pattern-action statement; for every line in which the third field is zero, the first field is printed.

Either the pattern or the action (but not both) in a pattern-action statement may be omitted. If a pattern has no action, for example,

	$3 == 0

then each line that the pattern matches (that is, each line for which the condition is true) is	printed. This program prints the two lines from	the emp.data file where the third field is zero:

	Beth 4.00 0 
	Dan  3.75 0

If there is an action with no pattern, for example, 

	{ print $1 }

then the action, in this case printing the first field, is performed for every input line.

Since patterns and actions are both optional, actions are enclosed in braces to distinguish them from patterns.

Running an AWK Program

There are several ways to run an awk program. You can type a command line of the form 

	awk 'program' input files 

to run the program on each of the specified input files. For example, you could type

	awk '$3 == 0 { print $1 }' file1 file2

to print the first field of every line of file 1 and file2 in which the third field is zero.

You can omit the input files from the command line and just type 

	awk  'program '

In this case awk will apply the program to whatever you type next on your terminal until you type an end-of-file signal (control-d on Unix systems). Here is a sample of a session on Unix:

====================

$ awk '$3 == 0 { print $1 } 
Beth	4.00	0 
Beth 
Dan	3.75	0
Dan 
Kathy	3.75	10 
Kathy	3.75	0 
Kathy
...

The heavy characters are what the computer printed. 

This behavior makes it easy to experiment with awk: type your program,then type data at it and see what happens. We again encourage you to try the examples and variations on them.

Notice that the program is enclosed in single quotes on the command line. This protects characters like $ in the program from being interpreted by the shell and also allows the program to be longer than one line.

This arrangement is convenient when the program is short (a few lines). If the program is long, however, it is more convenient to put it into a separate file, say progfile, and type the command line.
	awk -f progfile	optional list of input files 

The -f option instructs awk to fetch the program from the named file. Any filename can be used in place of progfile.


Errors

If you make an error in an awk program, awk will give you a diagnostic
message. For example, if you mistype a brace, like this: 

	awk '$3 == 0 [ print $1 }' emp.data

you will get a message like this:
	awk: syntax error at source line 1 
	context is
		$3==0>>> [<<< 
		extra } 
		missing  ]
	awk: bailing out at source line 1

"Syntax error" means that you have made a grammatical error that was detected at the place marked by >>> <<<. "Bailing out" means that no recovery was attempted. Sometimes you get a little more help about what the error was, such as a report of mismatched braces or parentheses.

Because of the syntax error, awk did not try to execute this program. Some errors, however, may not be detected until your program is running. For example, if you attempt to divide a number by zero, awk will stop its processing and report the input line number and the line number in the program at which the division was attempted.

============================================

1.2	Simple Output

The rest of this chapter contains a collection of short, typical awk programs based on manipulation of the emp.data file above. We'll explain briefly what's going on, but these examples are meant mainly to suggest useful operations that are easy to do with awk - printing fields, selecting input, and transforming data. We are not showing everything that awk can do by any means, nor are we going into many details about the specific things presented here. But by the end of this chapter, you will be able to accomplish quite a bit, and you'll find it much easier to read the later chapters.

We will usually show just the program, not the whole command line. In every case, the program can be run either by enclosing it in quotes as the first argument of the awk command, as shown above, or by putting it in a file and invoking awk on that file with the - f option.

There are only two types of data in awk: numbers and strings of characters. The emp.data file is typical of this kind of information - a mixture of words and numbers separated by blanks and/or tabs.

Awk reads its input one line at a time and splits each line into fields, where, by default, a field is a sequence of characters that doesn't contain any blanks or tabs. The first field in the current input line is called $1, the second $2, and so forth. The entire line is called $0. The number of fields can vary from line to line.

Often, all we need to do is print some or all of the fields of each line, perhaps performing some calculations. The programs in this section are all of that form.

Printing Every Line

If an action has no pattern, the action is performed for all input lines. The statement print by itself prints the current input line, so the program

	{ print }

prints all of its input on the standard output. Since $0 is the whole line, 

	{ print $0 }

does the same thing.

Printing Certain Fields

More than one item can be printed on the same output line with a single print statement.The program to print the first and third fields	of each	input line is

	{ print $1, $3 } 

With emp.data as input, it produces

======================

	Beth 0
	Dan 0
	Kathy 10
	Mark 20
	Mary 22
	Susie 18

Expressions separated by a comma in a print statementare , by default, separated by a single blank when they are printed. Each line produced by print ends with a newline character. Both of these defaults can be changed; we'll show how in Chapter 2.

NF, the Number of Fields

It might appear you must always refer to fields as $1, $2, and so on, but any expression can be used after $ to denote a field number; the expression is evaluated and its numeric value is used as the field number. Awk counts the number of fields in the current input line and stores the count in a built-in vari- able called NF. Thus, the program

	{ print NF, $1, $NF } 

prints the number of fields and the first and last fields of each input line.

Computing and Printing

You can also do computations on the field values and include the results in what is printed. The program

	{ print $1, $2 * $3 } 

is a typical example. It prints the name and total pay (rate times hours) for
each employee:

	Beth 0 
	Dan 0 
	Kathy 40 
	Mark 100 
	Mary 121 
	Susie 76.5

We'll show in a moment how to make this output look better.

Printing Line Numbers

Awk provides another built-variable, called NR, that counts the number of lines read so far. We can use NR and $0 to prefix each line of emp.data with its line number:

	{ print NR, $0 } 

The output looks like this:

	1 Beth	4.00	0
	2 Dan	3.75	0
	3 Kathy	4.00	10
	4 Mark	5.00	20
	5 Mary	5.50	22
	6 Susie	4.25	18

==================

Putting Text in the Output

You can also print words in the midst of fields and computed values: 

	{ print "total pay for", $1, "is", $2 * $3 }

prints

	total pay for Beth is 0 
	total pay for Dan is 0 
	total pay for Kathy is 40 
	total pay for Mark is 100 
	total pay for Mary is 121 
	total pay for Susie is 76.5

In the print statement, the text inside the double quotes is printed along with the fields and computed values.

1.3	Fancier Output

The print statement is meant for quick and easy output. To format the output exactly the way you want it, you may have to use the printf statement. As we shall	see in Section 2.4, printf can produce almost any kind of output, but in this section we'll only show a few of its capabilities.

Lining Up Fields

The printf statement has the form 

	printf(format, value1, value2, ••• , valueN,)

where format is a string that contains text to be printed verbatim, interspersed with specifications of how each of the values is to be printed. A specification is a % followed by a few characters that control the format of a value. The first specification tells how value1 is to be printed, the second how value2 is to be printed, and so on. Thus, there must be as many % specifications in format as values to be printed.

Here's a program that uses printf to print the total pay for every employee:

	{ printf("total pay for %s is $%.2f\n", $1, $2 * $3) } 

The specification string in the printf statement contains two %specifications.

=========================

The first, %s, says to print the first value, $1, as a string of characters; the second, %. 2f, says to print the second value, $2*$3, as a number with 2 digits after the decimal point. Everything else in the specification string, including the dollar sign, is printed verbatim; the \n at the end of the string stands for a new line, which causes subsequent output to begin on the next line. With emp. data as input, this program yields:


	total pay for Beth is $0.00 
	total pay for Dan is $0.00 
	total pay for Kathy is $40.00 
	total pay for Mark is $100.00 
	total pay for Mary is $121.00 
	total pay for Susie is $76.50

With printf, no blanks or newlines are produced automatically; you must create them yourself. Don't forget the \n.

Here's another program that prints each employee's name and pay: 

	{ printf("%-8s $%6.2f\n", $1, $2 * $3) }

The first specification, %-8s, prints a name as a string of characters left justified in a field 8 characters wide. The second specification, %6. 2f, prints the pay as a number with two digits after the decimal point, in a field 6 characters wide:

	Beth	$ 0.00 
	Dan	$ 0.00 
	Kathy	$ 40.00 
	Mark	$100.00 
	Mary	$121.00 
	Susie	$ 76.50

We'll show lots more examples of printf as we go along; the full story is in Section 2.4.

Sorting the Output

Suppose you want to print all the data for each employee, along with his or her pay, sorted in order of increasing pay. The easiest way is to use awk to pre- fix the total pay to each employee record, and run that output through a sorting program. On Unix, the command line

	awk '{ printf("%6.2f %s\n", $2 * $3, $0) }' emp.data | sort 

pipes the output of awk into the sort command, and produces:

===========================

0.00    Beth 4.00 0 
0.00    Dan 3.75 0 
40.00   Kathy 4.00 10 
76.50   Susie 4.25 18 
100.00  Mark 5.00 20 
121.00  Mary 5.50 22

1.4 Selection

Awk patterns are good for selecting interesting lines from the input for further processing. Since a pattern without an action prints all lines matching the pattern, many awk programs consist of nothing more than a single pattern. This section gives some examples of useful patterns.

Selection by Comparison

This program uses a comparison pattern to select the records of employees who earn $5.00 or more per hour, that is, lines in which the second field is greater than or equal to 5:

	$2 >= 5 

It selects these lines from emp.data:

	Mark	5.00	20 
	Mary	5.50	22

Selection by Computation 

The program

	$2 * $3 > 50 { printf("$%.2f for %s\n", $2 * $3, $1) } 

prints the pay of those employees whose total pay exceeds $50:

	$100.00 for Mark 
	$121.00 for Mary 
	$76.50 for Susie

Selection by Text Content 

Besides numeric tests, you can select input lines that contain specific words
or phrases. This program prints all lines in which the first field is Susie: 

	$1 == "Susie"

The operator == tests for equality. You can also look for text containing any of a set of letters, words, and phrases by using patterns called regular expressions. This program prints all lines that contain Susie anywhere:

==================

/Susie/ 

The output is this line:

	Susie	4.25	18

Regular expressions can be used to specify much more elaborate patterns; Section 2.1 contains a full discussion.

Combinations of Patterns

Patterns can be combined with parentheses and the logical operators &&, || ,
and !, which stand for AND, OR, and NOT. The program 

	$2 >= 4 || $3 >= 20

prints those lines where $2 is at least 4 or $3 is at least 20:

	Beth	4.00	0 
	Kathy	4.00	10 
	Mark	5.00	20 
	Mary	5.50	22 
	Susie	4.25	18

Lines that satisfy both conditions are printed only once. Contrast this with the following program, which consists of two patterns:

	$2 >= 4 
	$3 >= 20

This program prints an input line twice if it satisfies both conditions:

	Beth	4.00	0 
	Kathy	4.00	10 
	Mark	5.00	20 
	Mark	5.00	20 
	Mary	5.50	22 
	Mary	5.50	22 
	Susie	4.25	18

Note that the program 

	!($2 < 4 && $3 < 20)

prints lines where it is not true that $2 is less than 4 and $3 is less than 20; this condition is equivalent to the first one above, though perhaps less readable.

Data Validation

There are always errors in real data. Awk is an excellent tool for checking that data has reasonable values and is in the right format, a task that is often called data validation.

Data validation is essentially negative: instead of printing lines with desirable properties, one prints lines that are suspicious. The following program uses

================

comparison patterns to apply five plausibility tests to each line of emp. data:

	NF != 3   { print $0, "number of fields is not equal to 3" }
	$2 < 3.35 { print $0, "rate is below minimum wage" } 
	$2 > 10   { print $0, "rate exceeds $10 per hour" }
	$3 < 0    { print $0, "negative hours worked" }
	$3 > 60   { print $0, "too many hours worked" }

If there are no errors, there's no output.

BEGIN and END

The special pattern BEGIN matches before the first line of the first input ·file is read, and END matches after the last line of the last file has been processed. This program uses BEGIN to print a heading:

	BEGIN { print "NAME RATE HOURS"; print "" } 
	{ print }

The output is: 

	NAME  RATE  HOURS

	Beth  4.00   0 
        Dan   3.75   0 
	Kathy 4.00   10 
	Mark  5.00   20 
	Mary  5.50   22 
	Susie 4.25   18
You can put several statements on a single line if you separate them by semicolons. Notice that print "" prints a blank line, quite different from just plain print, which prints the current input line.

1.5	Computing with AWK

An action is a sequence of statements separated by newlines or semicolons. You have already seen examples in which the action was a single print statement. This section provides examples of statements for performing simple numeric and string computations. In these statements you can use not only the built-in variables like NF, but you can create your own variables for performing calculations, storing data, and the like. In awk, user-created variables are not declared.

Counting

This program uses a variable emp to count employees who have worked more than 15 hours:

==========

	$3> 15{emp=emp+1} 
	END	{ print emp, "employees worked more than 15 hours" }

For every line in which the third field exceeds 15, the previous value of emp is incremented by 1. With emp.data as input, this program yields:

	3 employees worked more than 15 hours 

Awk variables used as numbers begin life with the value 0, so we didn't need to
initialize emp. 

Computing Sums and Averages

To count the number of employees, we can use the built-in variable NR, which holds the number of lines read so far; its value at the end of all input is the total number of lines read.

	END { print NR, "employees" } 

The output is:

	6 employees 

Here is a program that uses NR to compute the average pay:

	{ pay =pay + $2 * $3 } 
	END { print NR, "employees"
	      print "total pay is", pay 
              print "average pay is", pay/NR
            }

The first action accumulates the total pay for all employees. The END action prints

	6 employees 
	total pay is 337.5 
	average pay is 56.25

Clearly,printf could be	used to	produce	neater output.	There's	also a potential error: in the unlikely case that NR is zero, the program will attempt to divide by zero and thus will generate an error message.

Handling Text

One of the strengths of awk is its ability to handle strings of characters as conveniently as most languages handle numbers. Awk variables can hold strings of characters as well as numbers. This program finds the employee who is paid the most per hour:

	$2 > maxrate { maxrate =$2; maxemp =$1 } 
	END { print "highest hourly rate:", maxrate, "for", maxemp }

It prints

=========

	highest hourly rate: 5.50 for Mary

In this program the variable maxrate holds a numeric value, while the variable maxemp holds a string. (If there are several employees who all make the same maximum pay, this program finds only the first.}

String Concatenation

New strings may be created by combining old ones; this operation is called concatenation. The program

	{ names = names $1 " " } 
	END { print names }

collects all the employee names into a single string, by appending each name and a blank to the previous value in the variable names. The value of names is printed by the END action:

	Beth Dan Kathy Mark Mary Susie

The concatenation operation is represented in an awk program by writing string values one after the other. At every input line, the first statement in the program concatenates three strings: the previous value of names, the first field, and a blank; it then assigns the resulting string to names. Thus, after all input lines have been read, names contains a single string consisting of the names of all the employees, each followed by a blank. Variables used to store strings begin life holding the null string (that is, the string containing no characters), so in this program names did not need to be explicitly initialized.

Printing the Last Input Line

Although NR retains its value in an END action, $0 does not. The program 

	{ last = $0 }
	END { print last } 

is one way to print the last input line:

	Susie	4.25	18 

Built-in Functions

We have already seen that awk provides built-in variables that maintain frequently used quantities like the number of fields and the input line number. Similarly, there are built-in functions for computing other useful values. Besides arithmetic functions for square roots, logarithms, random numbers, and the like, there are also functions that manipulate text. One of these is length, which counts the number of characters in a string. For example, this program computes the length of each person's name:

===============

	{ print $1, length($1) } 

The result:

	Beth 4 
	Dan 3 
	Kathy 5 
	Mark 4 
	Mary 4 
	Susie 5

Counting Lines, Words, and Characters

This program uses length, NF, and NR to count the number of lines, words, and characters in the input. For convenience, we'll treat each field as a word.

	{ nc =nc + length($0) + 1 
	  nw =nw + NF
        }
   END	{ print NR, "lines," nw, "words,", nc, "Characters" } 

The file emp.data has

	6 lines, 18 words, 77 characters

We have added one for the newline character at the end of each input line, since $0 doesn't include it.

1.6 Control-Flow Statements

Awk provides an if-else statement for making decisions and several statements for writing loops, all modeled on those found in the C programming language. They can only be used in actions.

If-Else Statement

The following program computes the total and average pay of employees making more than $6.00 an hour. It uses an if to defend against division by zero in computing the average pay.

	$2 > 6 { n =n + 1; pay =pay + $2 * $3} 
	END    { if (n > 0)
		     print n, "employees, total pay is" , pay, 
                              "average pay is" , pay/n
		 else 
		     print "no employees are paid more than $6/hour"
               }

The output for emp. data is:

=============

	no employees are paid more than $6/hour

In the if - else statement, the	condition following the	if is evaluated. If it is true,	the first print	statement is performed.	Otherwise, the second print statement is performed. Note that we can continue a long statement over several lines by breaking it after a comma.

While Statement

A while	statement has a	condition and a	body. The statements in	the body are performed repeatedly while the condition is true. This program shows how the value of an amount of money invested at a particular interest rate grows over a number of years, using the formula value = amount (1 +rate)years.

	# interest1 - compute compound interest 
	#    input: amount rate years 
	#    output: compounded value at the end of each year
	{ i=1 
	  while (i <= $3) {
	      printf("\t%.2f\n", $1 * (1 + $2) ^i) 
              i=i+1
          }
	} 
 
The condition is the parenthesized expression after the while; the loop body is the two statements enclosed in braces after the condition. The \t in the printf specification string stands for a tab character; the ^ is the exponentiation operator. Text from a # to the end of the line is a comment, which is ignored by awk but should be helpful to readers of the program who want to understand what is going on.

You can type triplets of numbers at this program to see what various amounts, rates, and years produce. For example, this transaction shows how $1000 grows at 6% and 12% compound interest for five years:

	$ awk -f interest1 
	1000 .06 5
		1060.00 
		1123.60 
		1191.02 
		1262.48 
		1338.23
	1000 .12 5 
		1120.00
		1254.40 
		1404.93 
		1573.52 
		1762.34

===========================

For Statement

Another statement, for, compresses into a single line the initialization, test, and increment that are part of most loops. Here is the previous interest computation with a for:

	# interest2 - compute compound interest
	# input: amount rate years
	# output: compounded value at the end of each year

	{for (i = 1; i <= $3; i = i + 1)
		 printf("\t%.2f\n", $1 * (1 + $2) ^ i)

  	}

The initialization i = 1 is performed once. Next, the condition i <= $3 is tested; if it is true, the printf statement, which is the body of the loop, is performed. Then the increment i = i + 1 is performed after the body, and the next iteration of the loop begins with another test of the condition. The code is more compact, and since the body of the loop is only a single statement, no braces are needed to enclose it.

1.7 Arrays

Awk provides arrays for storing groups of related values. Although arrays give awk considerable power, we will show only a simple example here. The following program prints its input in reverse order by line. The first action puts the input lines into successive elements of the array line; that is, the first line goes into 1ine[1], the second line into 1ine[2], and so on. The END action uses a while statement to print the lines from the array from last to first:

	# reverse - print input in reverse order by line 
		{line[NR] = $0 } # remember each input line

	END { i = NR # print lines in reverse order 
	      while (i > 0) {
		print line[i]
		i=i-1
               }
            }

With emp. data, the output is

	Susie 4.25 18 
	Mary 5.50 22 
	Mark 5.00 20 
	Kathy 4.00 10 
	Dan 3.75 0 
	Beth 4.00 0

================

Here is the same example with a for statement:

	# reverse - print input in reverse order by line
		{ line[NR] =$0 } # remember each input line

	END { for (i =NR; i > 0; i =i - 1) 
		print line[i]
	     }


1.8 A Handful of Useful "One-liners"

Although awk can be used to write programs of some complexity, many useful programs are not much more complicated than what we've seen so far. Here is a collection of short programs that you might find handy and/or instructive. Most are variations on material already covered.

	1. Print the total number of input lines: 

		END { print NR }

	2. Print the tenth input line: 

		NR == 10

3. Print the last field of every input line: 

		{ print $NF }

4. Print the last field of the last input line:
	
		{ field = $NF} 
		END { print field }

5. Print every input line with more than four fields: 

		NF > 4

6. Print every input line in which the last field is more than 4: 

		$NF > 4
7. Print the total number of fields in all input lines:

		{ nf = nf + NF } END { print nf }

8. Print the total number of lines that contain Beth:

		/Beth/ { nlines =nlines + 1 } 

		END { print nlines }

=========================


9. Print the largest first field and the line that contains it (assumes some $1 is positive):

	$1 > max { max=$1; maxline = $0 }
	END	 { print max, maxline }

10. Print every line that has at least one field: 
	
	NF > 0

11. Print every line longer than 80 characters: 

	length($0) > 80

12. Print the number of fields in every line followed by the line itself: 

	{ print NF, $0 }

13. Print the first two fields, in opposite order, of every line: 

	{ print $2, $1 }

14. Exchange the first two fields of every line and then print the line: 

	{temp=$1; $1 = $2; $2 = temp; print}

15. Print every line with the first field replaced by the line number: 

	{ $1 = NR; print }

16. Print every line after erasing the second field: 

	{ $2 = ""; print }

17. Print in reverse order the fields of every line:

	{for (i = NF; i > 0; i = i - 1) printf("%s ", $i) 
	printf("\n" )
	}

18. Print the sums of the fields of every line:

	{sum= 0 
         for (i = 1; i <= NF; i = i + 1) sum = sum + $i
	 print sum
	}

19. Add up all fields in all lines and print the sum:

	{ for (i = 1; i <= NF; i = i + 1) sum = sum + $i }
    END { print sum }

20. Print every line after replacing each field by its absolute value:

      	{for (i = 1; i <= NF; i = i + 1) if ($i < 0) Si = -$i 
         print
	}	

========================


1.9	What Next?

You have now seen the essentials of awk. Each program in this chapter has been a sequence of pattern-action statements. Awk tests every input line against the patterns, and when a pattern matches, performs the corresponding action. Patterns can involve numeric and string comparisons, and actions can include computation and formatted printing. Besides reading through your input files automatically, awk splits each input line into fields. It also provides a number of built-in variables and functions, and lets you define your own as well. With this combination of features, quite a few useful computations can be expressed by short programs - many of the details that would be needed in another language are handled implicitly in an awk program.

The rest of the book elaborates on these basic ideas. Since some of the examples are quite a bit bigger than anything in this chapter, we encourage you strongly to begin writing programs as soon as possible. This will give you familiarity with the language and make it easier to understand the larger programs. Furthermore, nothing answers questions so well as some simple experiments. You should also browse through the whole book; each example conveys something about the language, either about how to use a particular feature, or how to create an interesting program.

=========================

2	THE AWK LANGUAGE

This chapter explains, mostly with examples, the constructs that make up awk programs. Because it's a description of the complete language, the material is detailed, so we recommend that you skim it, then come back as necessary to check up on details.

The simplest awk program is a sequence of pattern-action statements: 

	pattern	{ action }
	pattern { action }

In some statements, the pattern may be missing; in others, the action and its enclosing braces may be missing. After awk has checked your program to make sure there are no syntactic errors, it reads the input a line at a time, and for each line, evaluates the patterns in order. For each pattern that matches the current input line, it executes the associated action. A missing pattern matches every input line, so every action with no pattern is performed at each line. A pattern-action statement consisting only of a pattern prints each input line matched by the pattern. Throughout most of this chapter, the terms "input line" and "record" are used synonymously. In Section 2.5, we will discuss multiline records, where a record may contain several lines.

The first section of this chapter describes patterns in detail. The second section begins the description of actions by describing expressions, assignments, and control-flow statements. The remaining sections cover function definitions, output, input, and how awk programs can call other programs. Most sections contain summaries of major features.

The Input File countries

As input for many of the awk programs in this chapter, we will use a file called countries. Each line contains the name of a country, its area in thousands of square miles, its population in millions, and the continent it is in. The data is from 1984; the USSR has been arbitrarily placed in Asia. In the file, the four columns are separated by tabs; a single blank separates North and South from America.

======================


The file countries contains the following lines:

	USSR 	  8649   275    Asia    
	Canada	  3852   25     North America
	China     3705   1032   Asia
  	USA	      3615   237    North America
	Brazil 	  3286   134    South America
	India 	  1267   746    Asia
	Mexico 	  762    78     North America
	France 	  211    55     Europe
	Japan 	  144    120    Asia 
	Germany   96     61     Europe 
	England   94     56     Europe

For the rest of this chapter, the countries file is used when no input file is mentioned explicitly.

Program Format

Pattern-action statements and the statements within an action are usually separated by newlines, but several statements may appear on one line if they are separated by semicolons. A semicolon may be put at the end of any statement.

The opening brace of an action must be on the same line as the pattern it accompanies; the remainder of the action, including the closing brace, may appear on the following lines.

Blank lines are ignored; they may be inserted before or after any statement to improve the readability of a program. Blanks and tabs may be inserted around operators and operands, again to enhance readability.

Comments may be inserted at the end of any line. A comment starts with the character # and finishes at the end of the line, as in

	{ print S1, $3 }     # print country name and population 

A long statement may be spread over several lines by inserting a backslash and newline at each break:

	{ print \ 
		$1,	# country name
		$2,	# area in thousands of square miles 
		$3 }	# population in millions

As this example shows, statements may also be broken after commas, and a comment may be inserted at the end of each broken line.

In this book we have used several formatting styles, partly to illustrate different ones, and partly to keep programs from occupying too many lines. For short programs like those in this chapter, format doesn't much matter, but consistency and readability will help to keep longer programs manageable.

==================

2.1 Patterns

Patterns control the execution of actions: when a pattern matches, its associated action is executed. This section describes the six types of patterns and the conditions under which they match.

=======================================================

               Summary of Patterns

1. BEGIN { statements } 
   The statements are executed once before any input has been read.

2. END { statements } 
   The statements are executed once after all input has been read.

3. expression { statements } 
   The statements are executed 'lt each input line where the expression is true, that is, nonzero or nonnull.

4. / regular expression / { statements	} 
   The statements are executed at each input line that contains a string matched by the regular expression.

5. compound pattern { statements } 
   A compound pattern combines expressions with && (AND), || (OR), !(NOT), and parentheses; the statements are executed at each input line where the compound pattern is true.

6. pattern 1, pattern 2	{ statements } 

   A range pattern matches each input line from a line matched by pattern 1 to the next line matched by pattern 2, inclusive; the statements are executed at each matching line.

BEGIN and END do not combine with other patterns. A range pattern cannot be part of any other pattern. BEGIN and END are the only patterns that require an action.

=================================================

BEGIN and END

The BEGIN and END patterns do not match any input lines. Rather, the statements in the BEGIN action are executed before awk reads any input; the statements in the END action are executed after all input has been read. BEGIN and END thus provide a way to gain control for initialization and wrapup. BEGIN and END do not combine with other patterns. If there is more than one BEGIN, the associated actions are executed in the order in which they appear in the program, and similarly for multiple END's. Although it's not mandatory, we put BEGIN first and END last.

One common use of a BEGIN action is to change the default way that input lines are split into fields. The field separator is controlled by a built-in variable

==========

called FS. By default, fields are separated by blanks and/or tabs; this behavior occurs when FS is set to a blank. Setting FS to any character other than a blank makes that character the field separator.

The following program uses the BEGIN action to set the field separator to a tab character (\t) and to put column headings on the output. The second printf statement, which is executed at each input line, formats the output into a table, neatly aligned under the column headings. The END action prints the totals. (Variables and expressions are discussed in Section 2.2.)

	# print countries with column headers and totals
	BEGIN { FS ="\t"	# make tab the field separator 
		printf("%10s %6s %5s %s\n\n",
			"COUNTRY",	"AREA",	" POP " , "CONTINENT")
	      }
	      { printf ("%10s %6d %5d	%s\n", $1, $2, $3, $4) 
		area = area + $2 
		pop = pop + $3
     	      }
	END   { printf ( "\n%10s %6d %5d\n", "TOTAL", area, pop) }

With the countries file as input, this program produces

	COUNTRY		AREA	POP	CONTINENT
 
	USSR 		8649 	275 	Asia 
	Canada		3852	25  	North America
	China 		3705 	1032 	Asia
	USA	    	3615	237 	North America
	Brazil		3286	134 	South America
	India 		1267 	746 	Asia 
	Mexico		762 	78 	    North America
	France		211	    55 	    Europe
	Japan 		144 	120 	Asia
	Germany		96	    61 	    Europe
	England		94	    56     	Europe

	 TOTAL    25681	  2819

Expressions as Patterns

Like most programming languages, awk is rich in expressions for describing numeric computations. Unlike many languages, awk also has expressions for describing operations on strings. Throughout this book, the term string means a sequence of zero or more characters. These may be stored in variables, or appear literally as string constants like "" or "Asia". The string "", which contains no characters, is called the null string. The term substring means a contiguous sequence of zero or more characters within a string. In every string, the null string appears as a substring of length zero before the first character, between every pair of adjacent characters, and after the last character.

==================

Any expression can be used as an operand of any operator. If an expression has a numeric value but an operator requires a string value, the numeric value is automatically transformed into a string; similarly, a string is converted into a number when an operator demands a numeric value.

Any expression can be used as a pattern. If an expression used as a pattern has a nonzero or nonnull value at the current input line, then the pattern matches that line. The typical expression patterns are those involving comparisons between numbers or strings. A comparison expression contains one of the six relational operators, or one of the two string-matching operators ~ (tilde) and !~ that will be discussed in the next section. These operators are listed in Table 2-1.

TABLE 2-1.  COMPARISON	OPERATORS

	     OPERATOR    MEANING
	 	    <	      less than 
		    <=     	  less than or equal to
		    ==        equal to
		    !=        not equal to
		    >=        greater than or equal to 
		    >         greater than
		    ~         matched
		    !~        not matched by

If the pattern is a comparison expression like NF> 10, then it matches the current input line when the condition is satisfied, that is, when the number of fields in the line is greater than ten. If the pattern is an arithmetic expression like NF, it matches the current input line when its numeric value is nonzero. If the pattern is a string expression, it matches the current input line when the string value of the expression is nonnull.

In a relational comparison, if both operands are numeric, a numeric comparison is made; otherwise, any numeric operand is converted to a string, and then the operands are compared as strings. The strings are compared character by character using the ordering provided by the machine, most often the ASCII character set. One string is said to be "less than" another if it would appear before the other according to this ordering, e.g., "Canada" < "China" and 
"Asia"< "Asian". 

The pattern

	$3/$2 >= 0.5

selects lines where the value of the third field divided by the second is numerically greater than or equal to 0.5, while

==========================

	$0 >= "M" 

selects lines that begin with an M, N, o, etc.:
	
	USSR   8649 275 Asia
	USA    3615 237	North America
	Mexico 762  78	North America

Sometimes the type of a comparison operator cannot be determined solely by the syntax of the expression in which it appears. The program

$1 < $4

could compare the first and fourth fields of each input line either as numbers or as strings. Here, the type of the comparison depends on the values of the fields, and it may vary from line to line. In the countries file, the first and fourth fields are always strings, so string comparisons are always made; the output is

	Canada  3852	25    North America
	Brazil  3286	134   South America
	Mexico  762	    78    North America
	England 94	    56    Europe

Only if both fields are numbers is the comparison done numerically; this would be the case with

	$2 < $3

on the same data. 
Section 2.2 contains a more complete discussion of strings, numbers, and expressions.

String-Matching Patterns

Awk provides a notation called regular expressions for specifying and matching strings of characters. Regular expressions are widely used in Unix programs, including its text editors and shell. Restricted forms of regular expressions also occur in systems like MS-DOS as "wild-card characters" for specifying sets of filenames.

A string-matching pattern tests whether a string contains a substring matched by a regular expression.

The simplest regular expression is a string of letters and numbers, like Asia, that matches itself. To turn a regular expression into a string-matching pattern, just enclose it in slashes:

	/Asia/

This pattern matches when the current input line contains the substring Asia, either as Asia by itself or as some part of a larger word like Asian or Pan-Asiatic .	

Note that blanks are significant within	regular	expressions: the string-matching pattern

=====================

========== String-Matching Patterns  ============

1. /regexpr / 
   Matches when the current input line contains a substring matched by regexpr.

2.expression	~ /regexpr / 
  Matches if the string value of expression contains a substring matched by regexpr.

3.expression	!~ /regexpr / 
  Matches if the string value of expression does not contain a substring matched by regexpr.

Any expression may be used in place of /regexpr/ in the context of ~ and !~.

=============================================

/ Asia /

matches only when Asia is surrounded by blanks. 

The pattern above is one of three types of string-matching patterns. Its form is a regular expression r enclosed in slashes: 

	/r/

This pattern matches an input line if the line contains a substring matched by r. 

The other two types of string-matching patterns use an explicit matching operator: 

	expression ~ /r/
	expression !~ /r/

The matching operator ~ means "is matched by" and !~ means "is not matched by." The first pattern matches when the string value of expression contains a substring matched by the regular expression r; the second pattern matches if there is no such substring.

The left operand of a matching operator is often a field: the pattern 

	$4 ~ /Asia/

matches all input lines in which the fourth field contains Asia as a substring, while

	$4 !~ /Asia/

matches if the fourth field does not contain Asia anywhere. 

Note that the string-matching pattern

    /Asia/ 

is a shorthand for

	$0 ~ /Asia/

=====================

Regular Expressions

A regular expression is a notation for specifying and matching strings. Like an arithmetic expression, a regular expression is a basic expression or one created by applying operators to component expressions. To understand the strings matched by a regular expression, we need to understand the strings matched by its components.

======================================

	Regular Expressions

1. The regular expression metacharacters are: 
	\ ^ $ . [ ] | ( ) * + ?

2. A basic regular expression is one of the following: 
   a nonmetacharacter, such as A. that matches itself. 
   an escape sequence that matches a special symbol: \t matches a tab (see Table 2-2). 
   a quoted metacharacter, such as \*, that matches the metacharacter literally. 
   ^, which matches the beginning of a string. 
   $, which matches the end of a string.
   ., which matches any single character. 
   a character class: [ABC] matches any of the characters A. B, or C. 
   character classes may include abbreviations: [A-Za-z] matches any single letter. 
   a complemented character class: [^0-9] matches any character except a digit.

3. These operators combine regular expressions into larger ones: 
   alternation: A: B matches A or B. 
   concatenation: AB matches A immediately followed by B. 
   closure: A* matches zero or more A's.
   positive closure: A+ matches one or more A's. 
   zero or one: A? matches the null string or A. 
   parentheses: (r) matches the same strings as r does.

=========================================================

The basic regular expressions are summarized in the table above. The characters

	\ ^ $ . [ ] | ( ) * + ?

are called metacharacters because they have special meanings. A regular expression consisting of a single nonmetacharacter matches itself. Thus, a single letter or digit is a basic regular expression that matches itself. To preserve the literal meaning of a metacharacter in a regular expression, precede it by a backslash. Thus, the regular expression \$ matches the character $. If a character is preceded by a single \· we'll say that character is quoted.

In a regular expression, an unquoted caret ^ matches the beginning of a string, an unquoted dollar-sign $ matches the end of a string, and an unquoted period .  matches any single character. Thus,


==============

    ^C      matches a C at the beginning of a string
    C$      matches a C at the end of a string
    ^C$     matches the string consisting of the single character c 
    ^.$     matches any string containing exactly one character
    ^...$   matches any string containing exactly three characters
    ...     matches any three consecutive characters
    \.$     matches a period at the end of a string

A regular expression consisting of a group of characters enclosed in brackets is called a character class; it matches any one of the enclosed characters. For example, [AEIOU] matches any of the characters A. E, I, O, or U.

Ranges of characters can be abbreviated in a character class by using a hyphen. The character immediately to the left of the hyphen defines the beginning of the range; the character immediately to the right defines the end. Thus,[0-9] matches any digit, and [a-zA-Z][0-9] matches a letter followed by a digit. Without both a left and right operand, a hyphen in a character class denotes itself, so the character classes [+-] and [-+] match either a + or a -. The character class [A-Za-z-]+ matches words that include hyphens.

A complemented character class is one in which the first character after the [ is a ^. Such a class matches any character not in the group following the caret.	Thus, [^0-9] matches any character	except a digit;	[^a-zA-Z] matches any character except an upper or lower-case letter.

    ^[ABC]      matches an A, B or C at the beginning of a string
    ^[^ABC]     matches any character at the beginning of a string. except A, B or C
    [^ABC]      matches any character other than an A, B Or C
    ^[^a-z]$    matches any single-character string. except a lower-case letter

Inside a character class, all characters have their literal meaning, except for the quoting character \, ^ at the beginning, and - between two characters. Thus, [.] matches a period and ^[^^] matches any character except a caret at the beginning of a string.

Parentheses are used in regular expressions to specify how components are grouped. There are two binary regular expression operators: alternation and concatenation. The alternation operator | is used to specify alternatives: if r1 and r2 are regular expressions, then r1 | r2 matches any string matched by r1 or by r2 .

There is no explicit concatenation operator. If r1 and r2 are regular expressions, then (r1) (r2 ) (with no blank between (r1) and (r2 )) matches any string of the form xy where r1 matches x and r2 matches y. The parentheses around r1 or r2 can be omitted, if the contained regular expression does not contain the alternation operator. The regular expression

(Asian|European|North American) (male|female) (black|blue)bird 

matches twelve strings ranging from

=====================

Asian male blackbird

to

North American female bluebird

The symbols *, +, and ? are unary operators used to specify repetitions in regular expressions. If r is a regular expression, then (r) * matches any string consisting of zero or more consecutive substrings matched by r, (r) + matches any string consisting of one or more consecutive substrings matched by r, and (r)? matches the null string or any string matched by r. If r is a basic regular expression, then the parentheses can be omitted.

    B*	    matches the null string orB or BB, and so on 
    AB*C	matches AC or ABC or ABBC, and so on 
    AB+C	matches ABC or ABBC or ABBBC, and so on 
    ABB*C	also matches ABC or ABBC or ABBBC, and so on 
    AB?C	matches AC or ABC
    [A-Z]+	matches any string of one or more upper-case letters 
    (AB)+C	matches ABC, ABABC, ABABABC, and so on

In regular expressions, the alternation operator | has the lowest precedence, then concatenation, and finally the repetition operators *, +, and ?. As in arithmetic expressions, operators of higher precedence are done before lower ones. These conventions often allow parentheses to be omitted: ab |cd is the same as (ab)|(cd), and ^ab|cd*e$ is the same as (^ab)|(c(d*)e$).

To finish our discussion of regular expressions, here are some examples of useful string-matching' patterns containing regular expressions with unary and binary operators, along with a description of the kinds of input lines they match. Recall that a string-matching pattern /r/ matches the current input line if the line contains at least one substring matched by r.

    /^(0-9]+$/ 
        matches any input line that consists of only digits
    /^(0-9][0-9](0-9]$/ 
        exactly three digits
    /^(\+|-)?[0-9]+\.?[0-9]*$/ 
        a decimal number with an optional sign and optional fraction
    /^[+-]?[0-9]+[.]?[0-9]*$/ 
        also a decimal number with an optional sign and optional fraction
    /^[+-]?([0-9]+[.]?[0-9]+1[.][0-9]+)([eE][+-]?[0-9]+)?$/ 
        a floating point number with optional sign and optional exponent
    /^[A-Za-z][A-Za-z0-9]*$/
        a letter followed by any letters or digits (e.g., awk variable name)
    /^[A-Za-z]S|^[A -Za-z][0-9]$/ 
        a letter or a letter followed by a digit (e.g., variable name in Basic)
    /^[A-Za-z][0-9]?$/ 
        also a letter or a letter followed by a digit

Since + and . are metacharacters, they have to be preceded by backslashes in the third example to match literal occurrences. These backslashes are not

========= 
needed within character classes, so the fourth example shows an alternate way to describe the same numbers.

Any regular expression enclosed in slashes can be used as the right-hand operand of a matching operator: the program

    $2 !~ /^[0-9]+$/ 

prints all lines in which the second field is not a string of digits.

Within regular expressions and strings, awk uses certain character sequences, called escape sequences, to specify characters for which there may be no other notation. For example, \n stands for a newline character, which cannot otherwise appear in a string or regular expression; \b stands for backspace; \t stands for tab; \007 represents the ASCII bell character; and \/ represents a slash. Escape sequences have special meaning only within an awk program; they are just characters in data. The complete list of escape sequences is shown in Table 2-2.

    TABLE 2-2. EsCAPE 

=================================

    SEQUENCES       MEANING
        \b          backspace
        \f          formfeed
        \n          newline (line feed)
        \r          carriage return
        \t          tab
        \ddd        octal value ddd where ddd is 1 to 3 digits between 0 and 7
        \c          any other character c literally (e.g., \\ for backslash, \" for ")

===================================



Table 2-3 summarizes regular expressions and the strings they match. The operators are listed in order of increasing precedence.

        TABLE	2-3 REGULAR	EXPRESSIONS

  EXPRESSION      MATCHES

    c               the nonmetacharacter c
    \c              escape sequence or literal character c
    ^               beginning of string
    $               end of string
    .               any character
    [c1c2...]       any character in c1 c2 ...
    [^C1C2...]      any character not in c1 c2 ...
    [c1-c2]         any character in the range beginning with c1 and ending	with c2 
    [^c1-c2]        any character not in the range c1 to c2
    r1|r2           any string matched by r1 or r2
    (r1)(r2)        any string xy where r1 matches x and r2 matches y
                        parentheses not needed around arguments with no alternations
    (r)*            zero or more consecutive strings matched by r 
    (r)+            one or more consecutive strings matched by r
    (r)?            zero or one string matched by r
                        parentheses not needed around basic regular expressions    
    (r)             any string matched by r


Compound Patterns

A compound pattern is an expression that combines other patterns, using parentheses and the logical operators || (OR), && (AND), and ! (NOT). A compound pattern matches the current input line if the expression evaluates to true. The following program uses the AND operator to select all lines in which the fourth field is Asia and the third field exceeds 500:

    $4 == "Asia" && $3 > 500 
    
The program

    $4 == "Asia" || $4 == "Europe"

uses the OR operator to select lines with either Asia or Europe as the fourth field. Because the latter query is a test on string values, another way to write it

=====================

is to use a regular expression with the alternation operator | : 

    $4 ~ /^(Asia|Europe)$/

(Two regular expressions are equivalent if they match the same strings. Test your understanding of the precedence rules for regular expressions: Are the two regular expressions ^Asia|Europe$ and ^(Asia|Europe)$ equivalent?)

If there are no occurrences of Asia or Europe in other fields, this pattern could also be written as

    /Asia/ || /Europe/ 
    
or even

    /Asia|Europe/

The || operator has the lowest precedence, then &&, and finally !. The && and || operators evaluate their operands from left to right; evaluation stops as soon as truth or falsehood is determined.

Range Patterns

A range pattern consists of two patterns separated by a comma, as in 

    pat1 ,	pat2

A range pattern matches each line between an occurrence of pat1 and the next occurrence of pat2 inclusive; pat2 may match the same line as pat1, making the range a single line. As an example, the pattern

    /Canada/, /USA/

matches lines starting with the first line that contains Canada up through the next line that contains USA

Matching begins whenever the first pattern of a range matches; if no instance of the second pattern is subsequently found, then all lines to the end of the input are matched:

    /Europe/, /Africa/

prints

    France	211	55	Europe 
    Japan   144 120 Asia 
    Germany 96	61	Europe 
    England 94	56	Europe

In the next example, FNR is the number of the line just read from the current input file and FILENAME is the filename itself; both are built-in vari- ables. Thus, the program

    FNR == 1, FNR == 5 { print FILENAME ": " $0 }

prints the first five lines of each input file with the filename prefixed. Alter- nately, this program could be written as
    
    FNR <= 5 { print FILENAME ": " $O } 
    
A range pattern cannot be part of any other pattern.

Summary of Patterns

Table 2-4 summarizes the kinds of patterns that can appear in pattern-action statements.

        Table 2-4  PATIERNS
==================================

   PATIERN              EXAMPLE          MATCHES

    BEGIN               BEGIN               before any input has been read 
    END                 END                 after all input has been read
    expression          $3 < 100            lines in which third field is less than 100
    string-matching     /Asia/              lines that contain Asia
    compound            $3 < 1 0 0&&        lines in which third field is less than 100 and
                        $4 == "Asia"        fourth field is Asia
    range               NR==10, NR==20      tenth to twentieth lines of input inclusive


======================================

2.2 Actions

In a pattern-action statement, the pattern determines when the action is to be executed. Sometimes an action is very simple: a single print or assignment. Other times, it may be a sequence of several statements separated by newlines or semicolons. This section begins the description of actions by discussing expressions and control-flow statements. The following sections present user- defined functions, and statements for input and output.

======================================

            Actions

The statements in actions can include: 

    expressions, with constants, variables, assignments, function calls, etc. 
    print expression-list 
    printf(format, expression-list) 
    if (expression)	statement 
    if (expression)	statement else	statement 
    while (expression) statement 
    for (expression; expression; expression) statement 
    for	(variable in array)	statement 
    do statement while (expression) 
    break 
    continue 
    next 
    exit
    exit expression 
    { statements }

======================================

        Expressions

We begin with expressions, since expressions are the simplest statements, and most other statements are made up of expressions of various kinds. An expres- sion is formed by combining primary expressions and other expressions with operators. The primary expressions are the primitive building blocks: they include constants, variables, array references, function invocations, and various built-ins, like field names.

Our discussion of expressions starts with constants and variables. Then come the operators that can be used to combine expressions. These operators fall into five categories: arithmetic, comparison, logical, conditional, and assignment. The built-in arithmetic and string functions come next, followed at the end of the section by the description of arrays.
Constants. There are two types of constants, string and numeric. A string constant is created by enclosing a sequence of characters in quotation marks, as

===============

in "Asia" or 11hello, world" or "". String constants may contain the escape sequences listed in Table 2-2.

A numeric constant can be an integer like 1127 , a decimal number like 3.14, or a number in scientific (exponential) notation like 0.707E-1. Different representations of the same number have the same numeric value: the numbers 1e6, 1.00E6, 10e5, 0 .1e7, and 1000000 are numerically equal. All numbers are stored in floating point, the precision of which is machine dependent.

Variables. Expressions can contain several kinds of variables: user-defined, built-in, and fields. The names of user-defined variables are sequences of letters, digits, and underscores that do not begin with a digit; all built-in vari- ables have upper-case names.

A variable has a value that is a string or a number or both. Since the type of a variable is not declared, awk infers the type from context. When necessary, awk will convert a string value into a numeric one, or vice versa. For example, in

    $4 == "Asia" { print $1, 1000 * $2 }

$2 is converted into a number if it is not one already, and $1 and $4 are con- verted into strings if they are not already.

An uninitialized variable has the string value "" (the null string) and the numeric value 0.

Built-In Variables. Table 2-5 lists the built-in variables. Some of these we have already met; others will be used in this and later sections. These variables can be used in all expressions, and may be reset by the user. FILENAME is set each time a new file is read. FNR, NF, and NR are set each time a new record is read; additionally, NF is reset when $0 changes or when a new field is created. RLENGTH and RSTART change as a result of invoking the match function.

Field Variables. The fields of the current input line are called $1, $2, through $NF; $0 refers to the whole line. Fields share the properties of other variables - they may be used in arithmetic or string operations, and may be assigned to. Thus one can divide the second field in each line of countries by 1000 to express areas in millions of square miles instead of thousands:

    { $2 =$2 / 1000; print } 

One can assign a new string to a field:

    BEGIN                   {FS	OFS ="\t" $4}
    $4 == "North America"   {$4	== "NA"}
    $4 == "South America"   {$4	== "SA"}
                            {print }

In this program, the BEGIN action sets FS, the variable that controls the input field separator, and OFS, the output field separator, both to a	tab. The print

====================

            TABLE 2-5. BUILT-IN VARIABLES

===============================================
VARIABLE        MEANING                                         DEFAULT

ARGC            number of command-line arguments                   - 
ARGV            array of command-line arguments                    -
FILENAME        name of current input file                         -
FNR             record number in current file                      -
FS              controls the input field separator                 ""
NF              number of fields in current record                 -
NR              number of records read so far                      -
OFMT            output format for numbers                          "%.6g"
OFS             output field separator                             " "
ORS             output record separator                            "\n"
RLENGTH         length of string matched by match function         -
RS              controls the input record separator                "\n"
RSTART          start of string matched by match function          -
SUBSEP          subscript separator                                "\034"


statement in the fourth line prints the value of $0 after it has been modified by previous assignments. This is important: when $0 is changed by assignment or substitution, $1, $2, etc., and NF will be recomputed; likewise, when one of $1, $2, etc., is changed, $0 is reconstructed using OFS to separate fields.

Fields can also be specified by expressions. For example, $(NF-1) is the next-to-last field of the current line. The parentheses are needed: $NF-1 is one less than the numeric value of the last field.

A field variable referring to a nonexistent field, e.g., $(NF+1), has as its initial value the null string. A new field can be created by assigning a value to it. For example, the following program creates a fifth field containing the popu- lation density:

    BEGIN	{ FS = OFS = "\t" } 
            {$5 = 1000 * $3 / $2 ; print }

Any intervening fields are created when necessary and given null values. 

The number of fields can vary from line to line, but there is usually an implementation limit of 100 fields per line.

Arithmetic Operators. Awk provides the usual +, -, *, I, %, and " arith- metic operators. The % operator computes remainders: x%y is the remainder when x is divided by y; its behavior depends on the machine if x or y is nega- tive. The " operator is exponentiation: x"y is xY. All arithmetic is done in floating point.

Comparison Operators. Comparison expressions are those containing either a relational operator or a regular expression matching operator. The relational

=================================
================================================

            Expressions

1. The primary expressions are: 
    numeric and string constants, variables, fields, function calls, array elements.
2. These operators combine expressions: 
    assignment operators = += -= *= I= %= "'= 
    conditional expression operator ? : 
    logical operators I I (OR), && (AND), I (NOT) 
    matching operators - and I - 
    relational operators < <= == I= > >= 
    concatenation (no explicit operator) 
    arithmetic operators + - * 1 % "' 
    unary +and - 
    increment and decrement operators ++and -- (prefix and postfix) 
    parentheses for grouping

=================================================

operators are <, <=, == (equals), != (not equals), >=, and >. The regular expression matching operators are - (is matched by) and 1- (is not matched by). The value of a comparison expression is l if it is true and 0 otherwise.

Similarly, the value of a matching expression is 1 if true, 0 if false, so 

    $4 - /Asia/

is 1 if the fourth field of the current line contains Asia as a substring, or 0 if it does not.

Logical Operators. The logical operators && (AND), II (OR), and I (NOT) are used to create logical expressions by combining other expressions. A logical expression has the value l if it is true and 0 if false. In the evaluation of a logi- cal operator, an operand with a nonzero or nonnull value is treated as true; other values are treated as false. The operands of expressions separated by && or II are evaluated from left to right, and evaluation ceases as soon as the value of the complete expression can be determined. This means that in

    expr 1	&.&.	expr 2 

expr2 is not evaluated if expr1 is false, while in

    expr3 || expr4 
    
expr4 is not evaluated if expr3 is true.

Newlines may be inserted after the && and I I operators. 

Conditional Expressions. A conditional expression has the form

    expr1 ? expr2 : expr3 

First, expr 1 is evaluated. If it is true, that is, nonzero or nonnull, the value of


================

the conditional expression is the value of expr2; otherwise, it is the value of expr3 •	Only one of expr2 and expr3 is evaluated.

The following program uses a conditional expression to print the reciprocal of $ 1, or a warning if $ 1 is zero:
    
    { print ($1 != 0 ? 1/$1 : "$1 is zero, line " NR) }

Assignment Operators. There are seven assignment operators that can be used in expressions called assignments. The simplest assignment is an expression of the form

    var = expr 

where var is a variable or field name, and expr is any expression. For example,to compute the total population and number of Asian countries, we could write

    $4 == "Asia" { pop =pop + $3; n == n + 1 } 
    END	         { print "Total population of the", n,
                    "Asian countries is", pop, "million."
                 }
                 
Applied to countries, the program produces 

    Total population of the 4 Asian countries is 2173 million.

The first action contains two assignments, one to accumulate population, and the other to count countries. The variables are not explicitly initialized, yet everything works properly because each variable is initialized by default to the string value "" and the numeric value 0.

We also use default initialization to advantage in the following program, which finds the country with the largest population:

    $3 > maxpop	{ maxpop = $3; country = $1	} 
    END	        {print "country with largest population:",
                    country, maxpop
                }
Note, however, that this program is correct only when at least one value of $3 is positive.

The other six assignment operators are +=, -=, *=, 1=, %=, and "=. Their meanings are similar: v op= e has the same effect as v = v ope, except that v is evaluated only once. The assignment

    pop =pop + $3 

can be written more concisely using the assignment operator +=:

    pop += $3

This statement has the same effect as the longer version -	the variable on the left is incremented by the value of the expression on the right - but += is shorter and runs faster.	As another example,

===============================

    { $2 /; 1000; print }

divides the second field by 1000, then prints the line. An assignment is an expression; its value is the new value of the left side.

Thus assignments can be used inside any expression. In the multiple assignment 

    FS = OFS = "\t"
both the field separator and the output field separator are set to tab. Assignment expressions are also common within tests, such as:

    if ((n = length($0)) > 0)	... 
    
    Increment and Decrement Operators. The assignment

        n = n+1

is usually written ++n or n++ using the unary increment operator ++, which adds 1 to a variable. The prefix form ++n increments n before delivering its value; the postfix form n++ increments n after delivering its value. This makes a difference when ++ is used in an assignment. If n is initially 1, then the assignment i =++n.increments n and assigns the new value 2 to i, while the assignment i = n++ increments n but assigns the old value 1 to i. To just increment n, however, there's no difference between n++ and ++n. The prefix and postfix decrement operator --, which subtracts 1 from a variable, works the same way.

Built-In Arithmetic Functions. The built-in arithmetic functions are shown in Table 2-6. These functions can be used as primary expressions in all expres- sions. In the table, x and y are arbitrary expressions.

TABLE 2-6. BUILT-IN ARITHMETIC FUNCTIONS

=========================================
    FUNCTION    VALUE RETURNED

    atan2(y,x)  arctangent of ylx in the range pai(3.14) to pai 
    cos(x)      cosine of x,with x in radians
    exp(x)      exponential function of x,ex
    int(x)      integer part of x; truncated towards 0 when x > 0
    log(x)      natural (base e) logarithm of x
    rand()      random number r , where 0 < r <1
    sin(x)      sine of x, with x in radians
    sqrt(x)     square root of x
    srand(x)    x is new seed for rand()

Useful constants can be computed with these functions: atan2 (0,-1) gives pai and exp(1) gives e, the base of the natural logarithms. To compute the base-10 logarithm of x, use log(x) / log(10).

===========================

The	function rand()	returns	a pseudo-random	floating point number greater than or equal to 0 and less than 1. Calling srand(x) sets the starting point of the generator from x. Calling srand() sets the starting point from the time of day. If srand is not called, rand starts with the same value each time the program is run.

The assignment 

    randint = int(n *rand()) + 1

sets randint to	a random integer between 1 and n inclusive.	Here we	are using the int function to discard the fractional part. The	assignment

    x = int(x + 0.5)

rounds the value of x to the nearest integer when xis positive.

String Operators. There is only one string operation, concatenation. It has no explicit operator: string expressions are created by writing constants, vari- ables, fields, array elements, function values, and other expressions next to one another. The program

    { print NR ":" $0 }

prints each line preceded by its line number and a colon, with no blanks. The number NR is converted to its string value (and so is $0 if necessary); then the three strings are concatenated and the result is printed.

Strings as Regular Expressions. So far, in all of our examples of matching expressions, the right-hand operand of - and 1- has been a regular expression enclosed in slashes. But, in fact, any expression can be used as the right operand of these operators. Awk evaluates the expression, converts the value to a string if necessary, and interprets the string as a regular expression. For example, the program

    BEGIN	{ digits = "^[0-9]+$" } 
    $2 - digits

will print all lines in which the second field is a string of digits. 

Since expressions can be concatenated, a regular expression can be built up from components. The following program echoes input lines that are valid floating point numbers:

    BEGIN { 
            sign = "[+-]?"
            decimal= "[0-9]+[.]?[0-9]*" 
            fraction= "[.][0-9]+" 
            exponent= "([eEl" sign "[0-9]+)?" 
            number= "A" sign"(" decimal "I" fraction ")" exponent "$"
    }
    $0 ~ number 
    
In a matching expression, a quoted string like "^[ 0-9] +$ " can normally be

==================================

used interchangeably with a regular expression enclosed in slashes, such as /"' [ 0-9] +$/. There is one exception, however. If the string in quotes is to match a literal occurrence of a regular expression metacharacter, one extra backslash is needed to protect the protecting backslash itself. That is,

    $0 - /(,+l-)[0-9]+/
    and
    $0 - "(,\+l-)[0-9]+"

are equivalent. 

This behavior may seem arcane, but it arises because one level of protecting backslashes is removed when a quoted string is parsed by awk. If a backslash is needed in front of a metacharacter to turn off its special meaning in a regular expression, then that backslash needs a preceding backslash to protect it in a string. If the right operand of a matching operator is a variable or field variable, as in

    X - $1

then the additional level of backslashes is not needed in the first field because backslashes have no special meaning in data.

As an aside, it's easy to test your understanding of regular expressions interactively: the program

    $1 - $2

lets you type in a string and a regular expression; it echoes the line back if the string matches the regular expression.

Built-In String Functions. Awk provides the built-in string functions shown in Table 2-7. In this table, r represents a regular expression (either as a string or enclosed in slashes), s and t are string expressions, and n and p are integers.

The	function index (s,t) returns the leftmost position where the string	t begins in s, or zero if t does not occur in s. The first character in a string is at position 1:

    index( "banana", "an"	) 
    
returns 2.

The function match(s ,r) finds the leftmost longest substring in the strings that is matched by the regular expression r. It returns the index where the substring begins or 0 if there is no matching substring. It also sets the built-in variables RSTART to this index and RLENGTH to the length of the matched substring.

The function split(s,a,fs) splits the string s into the array a according to the separator fs and returns the number of elements. It is described after arrays, at the end of this section.

================================

        TABLE 2-7. BUILT-IN STRING FUNCTIONS

===========================================================

    FUNCTION                    DESCRIPTION
    gsub(r,s)                   substitute s for r globally in $0,
                                    return number of substitutions made
    gsub(r ,s,t)                substitutes for r globally in string t, 
                                    return number of substitutions made
    index(s ,t)                 return first position of string t in s, or 0 if t is not present
    length(s)                   return number of characters in s
    match(s ,r)                 test whether s contains a substring matched by r,
    split(s ,a)                 return index or 0; sets RSTART and RLENGTH 
    split(s ,a,fs)              split s into array a on FS,return number of fields
    sprintf (fmt ,expr -list )  splits into array a on field separator fs,
                                    return number of fields
    sub(r ,s)                   return expr-list formatted according to format string fmt	
    sub(r,s,t)                  substitutes for the leftmost longest substring of $0
                                    matched by r, return number of substitutions made
    substr(s,p)                 return suffix ofs starting at position p
    substr (s ,p ,n)            return substring of s of length n starting at position p

==========================================================================================

The string function sprintf(format, expr1 , expr2 , ... , exprn) returns (without printing) a string containing expr., expr2, ..., exprn formatted according to the printf specifications in the string value of the expression format.

Thus, the statement 

    x =sprintf("%10s %6d", $1, $2)

assigns to x the string produced by formatting the values of $1 and $2 as a ten-character string and a decimal number in a field of width at least six. Section 2.4 contains a complete description of the format-conversion characters.

The functions sub and gsub are patterned after the substitute command in the Unix text editor ed. The function sub(r,s,t ) first finds the leftmost long- est substring matched by the regular expression r in the target string t; it then replaces the substring by the substitution string s. As in ed, uleftmost longest" means that the leftmost match is found first, then extended as far as possible.

In the target string banana, for example, anan is the leftmost longest sub- string matched by the regular expression (an)+. By contrast, the leftmost longest match of (an) * is the null string before b.

The sub function returns the number of substitutions made. The function sub(r,s) is a synonym for sub(r,s,$0).

The function gsub(r,s,t) is similar, except that it successively replaces the

====================================

leftmost longest nonoverlapping substrings matched by r with s in t; it returns the number of substitutions made. (The "g" is for "global," meaning every- where.)	For example, the program

    { qsub(/USA/, "United States"); print }

will transcribe its input, replacing all occurrences of "USA" by "United States". (In such examples, when $0 changes, the fields and NF change too.) And

    qsub(/ana/, "anda", "banana")

will replace banana by bandana; matches are nonoverlapping. In a substitution performed by either sub(r,s,t) or gsub(r,s,t), any occurrence of the character &. in s will be replaced by the substring matched by
r. Thus 
    
    qsub(/a/, "aba", "banana")

replaces banana by babanabanaba; so does 

    qsub(/a/, "&b&", "banana")

The special meaning of & . in the substitution string can be turned off by preced- ing it with a backslash, as in \& .

The function substr(s ,p) returns the suffix of s that begins at position p. If substr(s,p,n) is used, only the first n characters of the suffix are returned; if the suffix is shorter than n, then the entire suffix is returned. For example, we could abbreviate the country names in countries to their first three characters by the program

    { $1 =substr($1, 1, 3); print $0 } 
    
to produce

    uss 8649 275 Asia 
    Can 3852 25 North America 
    Chi 3705 1032 Asia 
    USA 3615 237 North America 
    Bra 3286 134 South America 
    Ind 1267 746 Asia 
    Mex 762 78 North America 
    Fra 211 55 Europe 
    Jap 144 120 Asia 
    Ger 96 61 Europe 
    Eng 94 56 Europe

Setting $1 forces awk to recompute $0 and thus the fields are now separated by a blank (the default value of OFS), no longer by a tab.

Strings are concatenated merely by writing them one after another in an expression. For example, on the countries file,







